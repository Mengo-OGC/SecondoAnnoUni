\section{Collezioni}
Il Java Collections Framework (JCF), parte del \inline{package java.util}, gestisce strutture dati e relativi algoritmi.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{JCF.png}
\end{figure}

Di nostro interesse sono:
\begin{itemize}
	\item Interfacce: Collection, List, Set, Iterator, Comparable.
	\item Classi: ArrayList, LinkedList, HashSet, HashMap.
	\item Classi Funzionalità: Collections, Arrays.
\end{itemize}

Fondamentalmente ci vengono fornite le collezioni (List, Set, Queue) e Map.

Tutti con un generic.

map: funzioni che metoono in relazione elementi di due gruppi.

in java le collezioni sono tutte mutabili, ovvero si possono modificare gli elementi.

tutte hanno add e toString().

\subsection{Iterator e foreach}
Il foreach può iterare qualunque oggetto che implementa l'interfaccia \inline{java.lang.Iterable<X>} che ha un metodo che genera e restituisce un oggetto che implementa \inline{Iterator} la quale definisce come scorrere gli elementi.

Ciò è possibile perchè il foreach conosce i metodi di entrambe le interfacce.

\multiline{}{}{CodiciEsempio/collection.java}

\subsection{Collection}
Interfaccia radice gerarchia interfacce di collezione (gruppi oggetti), estende \inline{Iterable}, e definisce:
\begin{itemize}
	\item Un costruttore vuoto. Assunto implicito.
	\item Un costruttore che accetta una Collection per l'inizializzazione. Assunto implicito.
	\item Operazioni di modifica opzionali.
	\item Operazioni di ricerca basete su Object.equals().
\end{itemize}

\multiline{}{}{CodiciEsempio/Collectoce.java}

I metodi \inline{contains e remove} applica il metodo \inline{Object.equals()} all'oggetto passato con tutti gli elementi della collezione.
Come argomento accetta \inline{Object} per poter confrontare oggetti anche non della stessa classe (potenzialmente uguali per le regole di confronto).

\subsubsection{Collezioni immutabili}
L'unico modo per creare una collezione di valori non modificabili ma solo leggibili.

\oneline{final ... = Set.of|copyOf(...);}


\inline{Set.of|copyOf()} permette che i valori non siano cambianti e \inline{final} fa si che la variabile non sia riassegnata, rendendo il tutto un blocco unico.

\subsection{List}
Collezione sequenzializzata con indice. Aggiunge metodi per accesso elementi secondo posizione (O-based).

Estende l'interfaccia \inline{ListIterator<E>} che estende \inline{Iterator<T>}.

Nota: Scandire quando possibile elemnti via iteratore e non indici.

\subsection{Set}
Collezione senza ordine e duplicati (\inline{Object.equals()} sempre \inline{false} e al massimo un \inline{null}). Non aggiunge metodi a Collection.

\bigskip

Per migliorare le prestazioni di \inline{contains()} si usa l'approccio \textbf{HashSet (O(1) aromtizzato)} che lega oggetto e posizione, o \textbf{TreeSet (O(logn))}.

Nota: I costruttori di HashSet accettano la dimensione iniziale stimata e un fattore di crescità, se basso hashing veloce, se alto hashing risparmia memoria.

\subsubsection{Ordinamento}
TreeSet (altre classi) assume un criterio d'ordinamento fra gli oggetti:
\begin{itemize}
	\item \textbf{Interno} alla classe tramite l'implementazione dell'interfaccia \inline{Comparable<T>}.
	\multiline{}{}{CodiciEsempio/Comparable.java}

	Permette di comparare due oggetti dello stesso tipo secondo un unico criterio.

	\oneline{obj1.compareTo(obj2);}

	\item \textbf{Esterno} alla classe tramite una classe comparatore che implementa l'interfaccia \inline{Comparator<T>}.
	\multiline{}{}{CodiciEsempio/Comparator.java}

	Permette di comparare due oggetti dello stesso tipo secondo tanti criteri quante sono le classi comparatore.

	\oneline{objComparator.compare(obj1, obj2);}
\end{itemize}

Sia \inline{compareTo} che \inline{compare} restituiscono 0 se i due oggetti sono guali, un numero positivo se this o o1 è maggiore oppure un numero negativo se this o o1 è minore.