\section{Dipendenze}
Il minimo numero di dipendenze fra classi sono manifestazione di "riuso" di codice e ne fanno un sistema e non un mero gruppo.

I tipi di dipendenze sono:
\begin{itemize}
	\item \textbf{Associazione} (uses),  un oggetto ne usa un altro.
	\item \textbf{Composizione} (has-a), un oggetto ne aggrega altri.

	Un oggetto di una classe \textit{si compone di} (campi) un insieme di altri oggetti, di altre classi.

	Tale composizione può essere permanente (campo final) o opzionale (campo possibilmente \inline{null}), multipla nota (più campi) o sconosciuta (campo array).
	\item \textbf{Specializzazione} (is-a), una classe ne specializza un'altra.
\end{itemize}

Nota: Nella composizione alla cancellazione dell'oggetto utilizzatore gli oggetti usati vengono cancellati a loro volta. Diversamente nell'aggregazione questi persistono.

\subsection{Interfacce}
Sopra tipo con caratteristiche comuni. Le classi implementative sono sotto tipi dell'interfaccia.

\bigskip

Separa esplicitamente l'interfaccia (contratto, fisso) dalla realizzazione (implementazione, variabile) della classe.

Consente diverse realizzazioni di un contratto, usabili omogeneamente. (più classi implementano medesime funzioni e si vuole usarele come fossero la stessa).

\oneline{interface <NomeInterfaccia> \{...\}}

\begin{itemize}
	\item Nuovo tipo solo dichiarabile (no \inline{new NomeInterfaccia()}) con valore oggetti delle classi che implementano l'interfaccia.

	\textbf{Principio sostituibilità di Liskov}: A sottotipo di B, ogni oggetto A deve essere usabile dove ci si attende un oggetto B.
	\item Un oggetto tipo interfaccia consente solo chiamate ai metodi definiti dall'interfaccia e esegue l'implementazione specifica classe implementativa dell'interfaccia.

	\oneline{<NomeInterfaccia> <nomeVar> = new <ClasseImplementativa>();}

	Tipo statico è interfaccia e tipo run-time è tipo classe implementativa.
	\textbf{Late binding}: Codice da eseguire scelto dinamicamente, dipende da classe implementativa dell'interfaccia tipo della variabile.

	\item Include solo intestazioni di metodi. Sono automaticamente \inline{public} e non si specifica.
	\item Compilato come una classe (produce un .class).

	\item Un interfaccia può estendere altre interfacce.

	\oneline{interface <NomeInterfaccia> extends int1[,...] \{...\}}

	Nel corpo dell'interfaccia si specificano solo i metodi che aggiunge.
\end{itemize}

\oneline{class <NomeClasse> implements <NomeInterfaccia[,...]> \{...\}}

\begin{itemize}
	\item Deve implementare il corpo di tutte le intetazioni di metodo delle interfacce (metodi in comune implementati una volta). La classe potrà avere altri metodi suoi.
	\item Le istanze avranno tipo la classe e le interfacce.
\end{itemize}

Nota: L'interfaccia è il sopra tipo/insieme delle classi, è più generale, ma fornisce meno funzionalità.

Nota: La classe che rispeccia l'interfaccia si chiama \textit{impNnomeInterfaccia}.

\subsubsection{Poliformismo}
\begin{itemize}
	\item \textbf{Inclusivo} (subtyping): applicazione principio sostituibilità.
	\item \textbf{Parametrico} (genericità): ???.
\end{itemize}

\subsection{Riuso con estensione/sostituibilità}
Data una classe (di cui possono non avere i sorgenti) ne realizzo un'altra con caratteristiche solo in parte diverse, ovvero una specializzazione. Questa nuova classe potrebbe sostituire la precedente (gerarchia \textit{is-a}).

Senzia violare \textbf{DRY}: Don't Repeat Yoursealf.

\subsubsection{Composizione/delegazione}
Nella nuova classe:
\begin{enumerate}
	\item \textbf{Incapsulare} un oggetto della classe da modificare/estendere mediante campo \inline{private final}\footnote{Cosi che l'oggetto una volta inizializzato non possa essere cambiato ma si possa allo stesso tempo adoperare metodi e campi di conseguenza.}. Sarà inizializzato nel costruttore della nuova classe.

	\item \textbf{Metodi} possono delegare all'oggetto incapsulato e essere di più o meno, ampliando cos'ì le funzionalità. Viola poco DRY.

	\item Combinare con l'uso delle interfacce per ottenere la sostituibilità.
\end{enumerate}
Quando si può è meglio usare i metodi "ridefiniti" che "originali" per rispettare l'incapsulamento.

\subsection{Ereditarietà}
Definisce una classse specializzandone una esistente \textbf{ereditando}. Rispetta DRY.

\oneline{class <ClasseFiglio> extends <ClassePare> \{...\}}

\begin{itemize}
	\item Eredita (usabili) campi, metodi, costruttori non privati.

	\item Costruttori non privati del padre richiamti solo da costruttori figlio (c.Figlio>=c.Padre), per inizializzare campi Padre.

	\oneline{super(<parametri>)}

	Se precesente deve essere la prima riga dei costruttori del figlio che devono avere almeno i parametri dei costruttori del padre.

	Costruttori default padre chiamato se \inline{super()} assente/posizione errata.
	\item Può aggiungere e modificare campi e metodi.

	\item Figlio acede a campi Padre (private) con get/set \inline{protected} per rispettare incapsulamento.
\end{itemize}

Nota: Bastano i binari per estendre una clsse.

\subsubsection{Overriding}
Riscrizione di uno o più metodi del Padre nel Figlio.

Il metodo riscritto può invocare la versione Padre con \inline{super.<metodoPadre()>}.

I metodi override hanno la notazione \inline{@Override}.