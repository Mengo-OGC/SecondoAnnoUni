\section{Dipendenze}
Il minimo numero di dipendenze fra classi sono manifestazione di "riuso" di codice e ne fanno un sistema e non un mero gruppo.

I tipi di dipendenze sono:
\begin{itemize}
	\item \textbf{Associazione} (uses),  un oggetto ne usa un altro.
	\item \textbf{Composizione} (has-a), un oggetto ne aggrega altri.

	Un oggetto di una classe \textit{si compone di} (campi) un insieme di altri oggetti, di altre classi.

	Tale composizione può essere permanente (campo final) o opzionale (campo possibilmente \inline{null}), multipla nota (più campi) o sconosciuta (campo array).
	\item \textbf{Specializzazione} (is-a), una classe ne specializza un'altra.
\end{itemize}

Nota: Nella composizione alla cancellazione dell'oggetto utilizzatore gli oggetti usati vengono cancellati a loro volta. Diversamente nell'aggregazione questi persistono.




\subsection{Poliformismo Inclusivo (subtyping)}
Fornire sovratipi che raccolgono classi uniformi tra loro.
Gode del principio di sostituibilità utile a creare collezioni omogene.

\textbf{Upcast}: Per il principio di sostituibilità quando ci si aspetta A si può usare B ma solo con le cose di A e non quelle esclusive di B. Ciò perchè B risponde almeno a tutti i messaggi di A (hanno i medesimi contratti).
\medskip

\textbf{Con Interfacce}
Sia B classe sottotipo di A interfaccia, con medesimi metodi (contratto) e altro possibilmente. Facile far aderire una classe a un iterfaccia.
\medskip

\textbf{Con Classi}
Sia B sottotipo di A, con medesimi metodi e campi (contratto+comportamento) e altro possibilmente. B e A hanno un comportamente compatibile.

\textbf{In memoria}: Intestazione (16byte) con indicazioni a run-time sulla classe dell'oggetto, tabella puntatori per vtable, campi privati di Object. Poi campi classe partendo da quelli della super classe.
\bigskip

\textbf{Poliformismo Parametrico} (genericità): ???.




\subsection{Interfacce}
Sopra tipo con caratteristiche comuni. Le classi implementative sono sotto tipi dell'interfaccia.

\bigskip

Separa esplicitamente l'interfaccia (contratto, fisso) dalla realizzazione (implementazione, variabile) della classe.

Consente diverse realizzazioni di un contratto, usabili omogeneamente. (più classi implementano medesime funzioni e si vuole usarele come fossero la stessa).

\oneline{interface <NomeInterfaccia> \{...\}}

\begin{itemize}
	\item Nuovo tipo solo dichiarabile (no \inline{new NomeInterfaccia()}) con valore oggetti delle classi che implementano l'interfaccia.

	\textbf{Principio sostituibilità di Liskov}: A sottotipo di B, ogni oggetto A deve essere usabile dove ci si attende un oggetto B.
	\item Un oggetto tipo interfaccia consente solo chiamate ai metodi definiti dall'interfaccia e esegue l'implementazione specifica classe implementativa dell'interfaccia.

	\oneline{<NomeInterfaccia> <nomeVar> = new <ClasseImplementativa>();}

	Tipo statico è interfaccia e tipo run-time è tipo classe implementativa.
	\textbf{Late binding}: Codice da eseguire scelto dinamicamente, dipende da classe implementativa dell'interfaccia tipo della variabile.

	\item Include solo intestazioni di metodi. Sono automaticamente \inline{public} e non si specifica.
	\item Compilato come una classe (produce un .class).

	\item Un interfaccia può estendere altre interfacce.

	\oneline{interface <NomeInterfaccia> extends int1[,...] \{...\}}

	Nel corpo dell'interfaccia si specificano solo i metodi che aggiunge.
\end{itemize}

\oneline{class <NomeClasse> implements <NomeInterfaccia[,...]> \{...\}}

\textbf{Una classe può implementare più interfacce.}

\begin{itemize}
	\item Deve implementare il corpo di tutte le intetazioni di metodo delle interfacce (metodi in comune implementati una volta). La classe potrà avere altri metodi suoi.
	\item Le istanze avranno tipo la classe e le interfacce.
\end{itemize}

Nota: L'interfaccia è il sopra tipo/insieme delle classi, è più generale, ma fornisce meno funzionalità.

Nota: La classe che rispeccia l'interfaccia si chiama \textit{impNnomeInterfaccia}.

Nota: Le interfacce possono avere metodi statici ma non si fa.



\subsection{Composizione/delegazione}
Data una classe (di cui possono non avere i sorgenti) ne realizzo un'altra con caratteristiche solo in parte diverse, ovvero una specializzazione. Questa nuova classe potrebbe sostituire la precedente (gerarchia \textit{is-a}).

Senzia violare \textbf{DRY}: Don't Repeat Yoursealf.

Nella nuova classe:
\begin{enumerate}
	\item \textbf{Incapsulare} un oggetto della classe da modificare/estendere mediante campo \inline{private final}\footnote{Cosi che l'oggetto una volta inizializzato non possa essere cambiato ma si possa allo stesso tempo adoperare metodi e campi di conseguenza.}. Sarà inizializzato nel costruttore della nuova classe.

	\item \textbf{Metodi} possono delegare all'oggetto incapsulato e essere di più o meno, ampliando cos'ì le funzionalità. Viola poco DRY.

	\item \textbf{Combinare} con l'uso delle interfacce per ottenere la sostituibilità.
\end{enumerate}
Quando si può è meglio usare i metodi "ridefiniti" che "originali" per rispettare l'incapsulamento.




\subsection{Ereditarietà}
Definisce una classse specializzandone una esistente \textbf{ereditando}. Rispetta DRY.

\oneline{class <ClasseFiglio> extends <ClassePare> \{...\}}

\textbf{Ereditarietà singola (tree), una classe può estenderne solo un'altra.}

\begin{itemize}
	\item Eredita (usabili) campi, metodi, costruttori non \inline{private}.

	\item Costruttori non privati del padre richiamti solo da costruttori figlio (c.Figlio>=c.Padre), per inizializzare campi Padre.

	\oneline{super(<parametri>)}

	Se precesente deve essere la prima riga dei costruttori del figlio che devono avere almeno i parametri dei costruttori del padre.

	Costruttori default padre chiamato se \inline{super()} assente/posizione errata.

	\item Figlio può aggiungere campi e metodi propri a quelli del pare (m.Figlio>=m.Padre) essendone una specializzazione.

	\item Figlio acede a campi Padre (\inline{private}) con get/set \inline{protected} per rispettare incapsulamento.

	\item Classe Figlio vede la "catena" di ereditarietà come un unica sovra classe da cui eredità.

	\item Una classe col modificatore \inline{final} non è ereditabile.
\end{itemize}

Nota: Bastano i binari per estendre una clsse.

Come le interfacce anche l'ereditarietà gode della sostituibilità. Posso fare variabili di tipo Padre ma che referenziano oggetti tipo Figlio. Questo perchè i Figli essondo delle specializzazioni "sono anche padre".

\subsubsection{Overriding}
Riscrizione di uno o più metodi \inline{public} del Padre nel Figlio.

\begin{itemize}
	\item Per sovrascrivere un metodo bisogna usare la stessa firma, a meno che del modificatore d'accesso che può solo aprirsi verso uno meno ristrettivo (fino a public).

	\item Un metodo definito col modificatore \inline{final} non è Overridabile.

	\item Il metodo riscritto può invocare la versione Padre con \inline{super.<metodoPadre()>}. Usabile non solo in caso di overdding.

	\item Un metodo ereditato o sovrascritto che usa \inline{this} chiamerà la versione del metodo della classe chiamante (come ogni metodo).

	\item I metodi override hanno opzionalmente la notazione \inline{@Override} utile al programmatore e al compilatore per controlli di sintassi.
\end{itemize}

\subsubsection{Vtable}
Nomi: vtable, call table, dispatch table.

Riporta la classe con il body da associare a ogni metodo definito o ereditato di una classe.

\textbf{Nella Memoria}: Nello stack abbiamo le variabili che fanno riferimento a oggetti di una certa classe, memorizzati nella heap. Dentro la memoria di questi oggetti nella heap si hanno i riferimenti alle vtable definite per ogni classe. Queste tabelle per ogni metodo della classe dicono se usare la versione della classe corrente (metodo ex-novo o sovrascritto) oppure di una sovraclasse.

\subsubsection{Classe Object}
Una classe estende sempre indirettamente la classe \inline{Object}.
\inline{Object} è la radice di ogni gerarchia d'ereditarietà.

Fornisce metodi di uso generico:
\begin{itemize}
	\item \textbf{toString() : String} Restituisce una rappresentazione in stringa dell'oggetto (utile per il debug).Automaticamente chiamato dall'operatore "+" nelle concatenazioni tra stringhe e oggetti.
	Ogni classe deve sovrascriverlo.
	\item \textbf{equals(Object obj) : boolean}: Dice se l'oggetto che lo invoca e quello passato come argomento sono uguali in base a criteri definiti da me.

	Deve essere riflessivo, simmetrico, transitivo, stabile e restituire false se passo \inline{null}.
	\item \textbf{hashCode() : int} Genera un hash code dell'oggetto stesso. Implementato insieme a equals().
	\item \textbf{getClass() : Class<?>} Restituisce un oggetto di Class che rappresenta la classe dell'oggetto stesso.
\end{itemize}

\textbf{Vantaggio?} Fattorizza comportamento comune e crea funzionalità che lavorano su qualunque oggetto.




\subsection{Classi Astratte}
Classi dal comportamento parziale, fatte per raggruppare contratti+comportamenti comuni e opzionalmente contratti successivamente specializzati.

\oneline{abstract class ...}

\begin{itemize}
	\item Fornisce codice comune a classi figlie che la specializzano.
	\item Metodi già implementati, spesso \inline{final}, definiscono il comportamento comune.

	Metodi \textit{astratti}, opzionali, hanno solo il contratto. Le classi figlio ne definiranno il comportamento specifico. Vanno definiti \inline{abstract}:
	\oneline{abstract <tipo> <nomeMetodo>([<parametri>]);}
	Metodi astratti si definiscono solo in classi astratte.

	\item Possono contenere campi, costruttori \inline{protected}.

	\item Classi non istanziabili (no \inline{new}).
	\item Una classe astratta può specializzare un'altra classe astratta o un interfaccia senza l'obbligo di specializzarne i metodi.
	\item Una classe astratta può estendere una classe non astratta.
	\item Una classe non astratta è tenuta a specializzare i metodi astratti della classe astratta da cui eredità.
\end{itemize}Intermedio tra ereditarietà tra classi e interfacce.

\subsection{Design Pattern}
Approccio fondamentale:

\begin{center}
	\begin{tikzcd}
		Interfacce               &  & {} \arrow[ll, "concetto"', no head, maps to] \\
		ClassiAstratte \arrow[u] &  & {} \arrow[ll, "condiceComune"', no head, maps to]              \\
		ClassiConcrete \arrow[u] &  & {} \arrow[ll, "implementazioni"', no head, maps to]
	\end{tikzcd}
\end{center}

Variabili, argomenti, tipi di ritorno sono interfacce mentre le \inline{new} sono solo di classi Concerete.

\begin{enumerate}
	\item \textbf{Iterator}: Oggetto usato per accedere ad'una sequenza d'elementi (presi da una sorgente di dati).
	\multiline{}{}{CodiciEsempio/iterator.java}
	\item ne manca uno...
	\item \textbf{Strategy}: Un oggetto A delega a un oggetto B l'implementazione d'una strategia che poi sarà usata dall'oggetto A tramite l'oggetto B.
	\item \textbf{Observer}: Oggetto osservatore si registra (attach) alla sorgente degli eventi per reagire a un evento specifico. Quando tale evento avviene la sorgente aziona (notify) l'osservatore che reagisce con un comportamente programmato.

	\begin{figure}[h]
		\centering
		\includegraphics[width=0.5\textwidth]{ObserverPattern.png}
	\end{figure}
\end{enumerate}
