\section{Git}
Git è un sistema di controllo di versione (SCV).

Un SCV può essere \textbf{distribuito}, ovvero ogni svilupparore localcomente ha una copia dell'intero "progetto" (repository), oppure \textbf{Centralizzato}, ovvero gli sviluppatori lavorano in sottoparti di un'unico progetto in remoto.

Git usa il modello distribuito per la maggiore scalabilità e facilità di branching e merging.

\subsection{Concetti}
\begin{itemize}
	\item \textbf{Repository}: Contiene l'interastoria del progetto tramite l'uso di meta dati contenuti in una cartella nascosta della root directory.

	La struttura di una repository git è un alberlo/grafo.

	\item \textbf{WorkTree/WorkingDirectory}: Insieme di file della root directory che costituiscono il progetto. Sono esclusi i meta dati.

	\item \textbf{Staging}: Stato, o contenitore, in cui metti le modifiche dei file del workTree che voglio salvare col prossimo commit. Dopo un commit lo staging è vuoto.

	\item \textbf{Commit}: Stato salvato del progetto tramite tracciamento differenziale\footnote{Raccoglie le modifiche neccessarie a trasformare il commit precedente in quello attuale.}. Inoltre crea uno \textit{snapshotting} dello stato del workTree.

	Meta dati di un commit: commit padre (assente=commit iniziale, multiplo=commit di fusione), autore, messaggio, id univoco.

	\item \textbf{Branch}: Sequenza di commit con un nome. Usato nome di default al primo commit se non è stato indicato.
\end{itemize}

\subsection{Riferimenti ai commit}
I riferimenti ai commit sono chiamati \textit{tree-ish} e sono validi il nome del commit, il suo id (full o short), il nome del branch che fa riferimento all'ultimo commit avvenuto su quel branch, e HEAD.

HEAD è un nome speciale di commit che si riferisce al commit corrente ed'è linkata al branch del commit. Essenziale per muoversi nel workTree.

\begin{itemize}
	\item \textbf{Riferimento assoluto}: Esplicito il tree-ish a cuoi voglio spostare la HEAD.

	\item \textbf{Riferimento relativo}: Si fa \inline{tree-ish~i} per dire l'i-esimo commit padre del tree-ish in cui voglio spostare la HEAD. In caso di merge seleziona il primo.
\end{itemize}

A ogni nuovo commit la HEAD vi ci si sposta automaticamente.

\subsection{Operazioni base}
\begin{itemize}
	\item \textbf{Configurazione Globale}: Configura git a livello di sistema.

	\oneline{git config --global category.option value}

	\item \textbf{Configurazione Repository}: La configurazione di repository corrente sovrascrive quella globale.

	\oneline{git config category.option value}

	\item \textbf{Inizializzazione Repository}: Inizializza una repository nella directory corrente tramite il .git che esplicità la root directory.

	\oneline{git init}

	Eliminare il .git comporta l'eliminazione della repository locale.

	\item \textbf{Staging}: Per aggiungere allo staging:

	\oneline{git add <files>}

	Aggiungere allo staging un file che non esiste più è l'equivalente della sua eliminazione nel prossimo commit.

	Aggiungere allo staginig un file che ha lo stesso contenuto di un file che non esiste più è l'equivalente della sua rinominazione.

	Per rimuovere dallo staging:

	\oneline{git reset <files>}

	\item \textbf{Commit}: Fa il salvataggio in un nuovo commit dei file selezionati nello staging. Data e id autogenerati.
	La HEAD deve essere sull'ultimo commit di un branch.

	\oneline{git commit -m "..."}

	Richiede la configurazione del nome e email dell'autore e del nome del branch.
	Cose da scrivere in un messaggio: file eliminati, aggiunte, modifiche.

	\item \textbf{Stato della repository}: Mostra informazioni sul branch corrente, quali file sono modificati, lo stato dello staiging:

	\oneline{git status}

	\item \textbf{Checkout}: Sposta la HEAD nel tree-ish specificato, se non ci sono modifiche volatili, aggiornando i file alla versione del tree-ish specifiato.

	\oneline{checkout <tree-ish>}

	Fatto checkout si è in modalità \textit{detached head} (HEAD delinkata dal branch) e i commit fatti saranno persi fino.

	\item \textbf{Estrazione di file}: Altra funzione di checkout che permette di estrarre (riprisinare lo stato nella HEAD) da un tree-ish i file indicati.

	\oneline{git checkout <tree-ish> -- file1 [file1 ...]}

	\item \textbf{Visualizzazone Storia}: Per visualizzare di base i commit dal HEAD alla root:

	\oneline{git log [--oneline] [--all] [--graph]}

	\item \textbf{Differenze}: Visualizza le linee modificate dei file tra due commit.
	\begin{itemize}
		\item \inline{git diff} mostra righe aggiunte in staging.
		\item \inline{git diff --staged} mostra righe differenti tra HEAD e workTree.
		\item \inline{git diff <tree-ish>} mostra righe differenti tra tree-ish e workTree.
		\item \inline{git diff --staged <tree-ish>} mostra righe differenti tra HEAD e workTree includendo le modifiche in staging.
		\item \inline{git diff <from> <to>} mostra righe differenti tra due tree-ish.
	\end{itemize}
\end{itemize}

Alcuni category.option: user.name, user.email, core.editor, init.defaultbranch.

\subsection{Ignoring files}
Per escludere automaticamente alcuni file della repository locale in quella remota, senza farlo a mano, si usa il file \textbf{.gitignore}.

Va inserito nella workTree root.

Ad'ogni aggiunta nello staging git ignorerà automaticamente tutti i file nei percorsi o delle estensioni specificate dentro .gitignore. Ignorato se si usa \inline{git add --force ...}.

Per creare/aggiungere .gitignore si fa da cli:

\oneline{echo ... >> .gitignore}

Per fare delle eccezioni di file che vogliamo includere nello staging:

\oneline{!<nomeFile.estensione>}


Nota: La compatibilità tra le modalità di andata a capo (LF e CRLF), in parte compensata da git automaticamente, è risolta esplicitando in \textbf{.gitattributs} quale modalità usare in base al tipo del file. Tranne per i file di estensioni specifiche di windows il default è LF. Va inserito nella workTree root.

\subsection{Branch}
Le brach sono le linee/rami di sviluppo identificati da un'etichetta. Funzionano come etichette mobili allegati alla creazione al commit HEAD e si sposta insieme ad'esso l'etichetta.

Per linkare la HEAD ai brach serve un \inline{checkout} esplicito.

\oneline{git branch brach\_name}

In modalità DETACHED\_HEAD possiamo creare un brach, farci modifiche per poi salvarle serve linkargi la HEAD (checout, add, commit).

\textbf{brach one-shot}: \inline{git checkout -b new-branch-name}

\subsection{Merging}
I merge sono l'unificazione di più branch target con il branch corrente (quello a cui è linkato HEAD). Gl'ultimi commit dei branch verranno uniti in un nuovo commit che apparterrà al branch corrente.

\oneline{git merge target}

Il commit conclude la fase di merging. Commit precompilato di un merge corretto: \inline{git commit --no-edit}.

\textbf{Avanzamento veloce}: Non è un'unione di branch ma uno spostamento per allineare due branch sulle modifiche. Uno dei due branch deve essere incluso nell'altro.