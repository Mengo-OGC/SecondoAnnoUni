\section{Git}
Git è un sistema di controllo di versione (SCV).

Un SCV può essere \textbf{distribuito}, ovvero ogni svilupparore localcomente ha una copia dell'intero "progetto" (repository), oppure \textbf{Centralizzato}, ovvero gli sviluppatori lavorano in sottoparti di un'unico progetto in remoto.

Git usa il modello distribuito per la maggiore scalabilità e facilità di branching e merging.

\subsection{Concetti}
\begin{itemize}
	\item \textbf{Repository}: Contiene l'interastoria del progetto tramite l'uso di meta dati contenuti in una cartella nascosta della root directory.

	La struttura di una repository git è un alberlo/grafo.

	\item \textbf{WorkTree/WorkingDirectory}: Insieme di file della root directory che costituiscono il progetto. Sono esclusi i meta dati.

	\item \textbf{Staging}: Stato, o contenitore, in cui metti le modifiche dei file del workTree che voglio salvare col prossimo commit. Dopo un commit lo staging è vuoto.

	\item \textbf{Commit}: Stato salvato del progetto tramite tracciamento differenziale\footnote{Raccoglie le modifiche neccessarie a trasformare il commit precedente in quello attuale.}. Inoltre crea uno \textit{snapshotting} dello stato del workTree.

	Meta dati di un commit: commit padre (assente=commit iniziale, multiplo=commit di fusione), autore, messaggio, id univoco.

	\item \textbf{Branch}: Sequenza di commit con un nome. Usato nome di default al primo commit se non è stato indicato.

	\item \textbf{Remotes}: Copie della repository remote conosciute dal repository locale. Ogniuna ha nome e URI.

	I branch remoti possono essere identificati con \inline{remoteName/branchName}.
\end{itemize}

\subsection{Riferimenti ai commit}
I riferimenti ai commit sono chiamati \textit{tree-ish} e sono validi il nome del commit, il suo id (full o short), il nome del branch che fa riferimento all'ultimo commit avvenuto su quel branch, e HEAD.

\bigskip

\textbf{HEAD}: Nome speciale di commit che si riferisce al commit corrente ed'è linkata al branch del commit. Essenziale per muoversi nel workTree.

\begin{itemize}
	\item \textbf{Riferimento assoluto}: Esplicito il tree-ish a cuoi voglio spostare la HEAD.

	\item \textbf{Riferimento relativo}: Si fa \inline{tree-ish~i} per dire l'i-esimo commit padre del tree-ish in cui voglio spostare la HEAD. In caso di merge seleziona il primo.
\end{itemize}

A ogni nuovo commit la HEAD vi ci si sposta automaticamente.

\bigskip

\textbf{DETACHED\_HEAD}: Modalità in cui la Head è delinkata da ogni branch e i commit fatti saranno persi.

\subsection{Operazioni base}
\begin{itemize}
	\item \textbf{Configurazione Globale}: Configura git a livello di sistema.

	\oneline{git config --global category.option value}

	\item \textbf{Configurazione Repository}: La configurazione di repository corrente sovrascrive quella globale.

	\oneline{git config category.option value}

	\item \textbf{Inizializzazione Repository}: Inizializza una repository (vuota) nella directory corrente tramite il .git che esplicità la root directory. Il remote non è noto.

	\oneline{git init}

	Eliminare il .git comporta l'eliminazione della repository locale.

	\item \textbf{Staging}: Per aggiungere allo staging:

	\oneline{git add <files>}

	Aggiungere allo staging un file che non esiste più è l'equivalente della sua eliminazione nel prossimo commit.

	Aggiungere allo staginig un file che ha lo stesso contenuto di un file che non esiste più è l'equivalente della sua rinominazione.

	Per rimuovere dallo staging:

	\oneline{git reset <files>}

	\item \textbf{Commit}: Fa il salvataggio in un nuovo commit dei file selezionati nello staging. Data e id autogenerati.
	La HEAD deve essere sull'ultimo commit di un branch.

	\oneline{git commit -m "..."}

	Richiede la configurazione del nome e email dell'autore e del nome del branch.
	Cose da scrivere in un messaggio: file eliminati, aggiunte, modifiche.

	\item \textbf{Stato della repository}: Mostra informazioni sul branch corrente, quali file sono modificati, lo stato dello staiging:

	\oneline{git status}

	\item \textbf{Checkout}: Sposta la HEAD nel tree-ish specificato, se non ci sono modifiche volatili, aggiornando i file alla versione del tree-ish specifiato.

	\oneline{checkout <tree-ish>}

	La HEAD va in DETACHED\_HEAD con \inline{checkout <commit>} e ne esce con \inline{checout <branch>}.

	\item \textbf{Estrazione di file}: Altra funzione di checkout che permette di estrarre (riprisinare lo stato nella HEAD) da un tree-ish i file indicati.

	\oneline{git checkout <tree-ish> -- file1 [file1 ...]}

	\item \textbf{Visualizzazone Storia}: Per visualizzare di base i commit dal HEAD alla root.

	\oneline{git log [--oneline] [--all] [--graph]}

	Il parametro \inline{--all} mostra anche i branch fetched di \inline{clone}.

	\item \textbf{Visualizzazione branch}: Visualizza tutti i branch locali e remoti.

	\oneline{git branch -a}

	\item \textbf{Differenze}: Visualizza le linee modificate dei file tra due commit.
	\begin{itemize}
		\item \inline{git diff} mostra righe aggiunte in staging.
		\item \inline{git diff --staged} mostra righe differenti tra HEAD e workTree.
		\item \inline{git diff <tree-ish>} mostra righe differenti tra tree-ish e workTree.
		\item \inline{git diff --staged <tree-ish>} mostra righe differenti tra HEAD e workTree includendo le modifiche in staging.
		\item \inline{git diff <from> <to>} mostra righe differenti tra due tree-ish.
	\end{itemize}
\end{itemize}

Alcuni category.option: user.name, user.email, core.editor, init.defaultbranch.

\subsubsection{Operazioni remote}
\begin{itemize}
	\item Visualizza la lista delle remote conosciute dalla repository locale.

	\oneline{git remote -v}

	\item Mostra le informazioni di una remote.

	\oneline{git remote show nomeRemote}

	\item Aggiunge una remote a quelle conosciute alla repository locale.

	\oneline{git remote add nomeRemote URI}

	\item Fa "dimenticare" alla repository locale della remote.

	\oneline{git remote remove nomeRemote}

\end{itemize}

\subsection{Ignoring files}
Per escludere automaticamente alcuni file della repository locale in quella remota, senza farlo a mano, si usa il file \textbf{.gitignore}.

Va inserito nella workTree root.

Ad'ogni aggiunta nello staging git ignorerà automaticamente tutti i file nei percorsi o delle estensioni specificate dentro .gitignore. Ignorato se si usa \inline{git add --force ...}.

Per creare/aggiungere .gitignore si fa da cli:

\oneline{echo ... >> .gitignore}

Per fare delle eccezioni di file che vogliamo includere nello staging:

\oneline{!<nomeFile.estensione>}


Nota: La compatibilità tra le modalità di andata a capo (LF e CRLF), in parte compensata da git automaticamente, è risolta esplicitando in \textbf{.gitattributs} quale modalità usare in base al tipo del file. Tranne per i file di estensioni specifiche di windows il default è LF. Va inserito nella workTree root.

\subsection{Branch}
Le brach sono i rami di sviluppo identificati da etichette.
L'etichetta di una branch è mobile e sempre linkata, dalla creazione, al commit HEAD.

Creazione di una branch:

\oneline{git branch brach\_name}

Per linkare la HEAD ai brach serve un \inline{checkout} esplicito.

\bigskip

Se siamo in DETACHED\_HEAD possiamo creare un brach e linkare la HEAD:

\textbf{brach one-shot}: \inline{git checkout -b new-branch-name}

\subsection{Merging}
I merge sono l'unificazione di più branch target con il branch corrente (quello a cui è linkato HEAD). Gl'ultimi commit dei branch verranno uniti in un nuovo commit che apparterrà al branch corrente.

\oneline{git merge target}

Il commit conclude la fase di merging. Commit precompilato di un merge corretto: \inline{git commit --no-edit}.

\textbf{Avanzamento veloce}: Non è un'unione di branch ma uno spostamento per allineare due branch sulle modifiche. Uno dei due branch deve essere incluso nell'altro.

\subsection{Upstream branches}
Se branch remoti e locali sono associati (sono copie dello stesso branch) il branch remoto è l'\textbf{upstream branch}, configurabile con:

\oneline{git branch --set-upstream-to=remote/branchName}

\subsection{Clonazione Repository remote}
Copia l'intera storia della repository remota (URI) nella destinazione indicata (opzionale), ma "abilita" (checked out) solo il branch con la HEAD attaccata.

\oneline{git clone URI [destination]}

\begin{itemize}
	\item Se la destinazione non è vuota da errore.
	\item Se la destinazione non è indicata viene creata una cartalla con nome l'ultimo segmento di URI.
	\item L'URI può essere locale o remoto.
	\item Viene creato un remote (nome=origin) automaticamente.
\end{itemize}

Il branch locale "abilitato" (checked out), detto default branch, ha lo stesso nome del branch remoto.

\medskip

Posso "abilitare" i branch \textbf{fetched} con \inline{git checkout nomeBranchRemoto}.

\medskip

I branch remoti sono \textbf{upstream branch}.

\bigskip

Nota: Quando si lavora con più remote o remote e locale i branch vanno cambiati di nome quando serve (tipo i main) o in certe operazioni (merge) si può referenziare con \inline{nomeRemote/nomeBranch}.

\subsection{Fetching}
Controlla se una remote ha degli aggiornamenti (commit, branch, tag) disponibili e nel caso li scarica.

\oneline{git fetch nomeRemote}

Se HEAD è attaccata e il branch corrente ha un upstream, il controllo è sul remote/origin del branch.

\oneline{git fetch}

Per applicare gli aggiornamenti serve un merge (tra modifiche locali e quelle scaricate).

\textbf{fast-forward}: Caso di merge dove in locale non ci sono aggiune rispetto alla remote (si copia solo).

\subsubsection{pull}
Unione di fetch e merge.
\begin{itemize}
	\item \oneline{git pull} fa fetch dal remote/origin e mergia nel branch attaccato alla HEAD.
	\item \oneline{git pull nomeRemote} fa fetch dalla remote indicata nel branch attaccato alla HEAD.
	\item \oneline{git pull nomeRemote nomeBanch} fa fetch della remote indicata nel branch indicato.
\end{itemize}

\subsection{push}
Manda i cambiamenti locali al branch della remote, aggiornando la remote HEAD. Necessità privilegi di scrittura.

\oneline{git push remote branch}

Omettendo remote o branch viene usato.

\oneline{git push}

Si può impostare upstream a tempo di push.

\oneline{git push -u myremote mybranch}

Nota: \inline{git push --tags} manda i tag e \inline{git push --follow-tags} manda commit e poi tags.

\bigskip

\textbf{Fallimento}: se branch remote non è padre di branch locale, ossia: branch remote ha file non presentei in locale, branch remote non può fare fast-forward, branch remote non è sotto insieme di locale.

\subsection{GitHub}
Fornisce funzionalità come:
\begin{itemize}
	\item \textbf{Forks}: Copia di una repostiory associata a diversi utenti/organizzazioni.
	\item \textbf{Richieste di pull/push}: Permette di estrarre aggiornamenti dai fork dei non "autorizzati":
	\item \textbf{Monitoraggio dei problemi}.
\end{itemize}

Su github i repository remoti sono identificati univocamente da owner/repoName.

\textbf{Autentificazione}: Via https con token o ssh (procedura slideGit3 pag.27).