\section{GUI}
In Java 1 e 2 per la gui si usava AWT (Abstract Window Toolkit) mentre dalla versione 5 si è passati a Swing (basato su AWT) e dalla versione 8 si è diffoso JavaFX e SWT.

I package sono \inline{java.awt} e \inline{javax.swing} (classi con nome J*) le cui classi base sono:
\begin{itemize}
	\item \inline{JFrame}: Finestra con "cornice". Comporta la creazione di un EDT (Event Dispatch Thread).
	\item \inline{Jpanel}: Pannello di componenti inseribili in un JFrame.
	\item \inline{JComponent}: Componenti (dimensione "preferità" predefinità).
	\item \inline{JDialog}: Finestra di dialogo.
	\item \inline{JWindow}: Componente piazzabile nel desktop.
\end{itemize}

La definizione di una GUI si apre con la creazione di un oggetto JFrame e si chiude con il rendere visibile il JFrame tramite \inline{seVisible()}.

Si fa un \inline{interface} in modo da separare le "azioni" dai dettagli implementativi delegando a una classe personalizzata la gestione del frame estendendo JFrame.

\textbf{Il layout di un JPanel} è gestito dal un oggetto di classe \inline{LayoutManager} che incapsula la strategia d'inserimento dei componenti. Strategie:
\begin{itemize}
	\item \inline{FlowLayout (default)}: Affianca in riga i componenti finchè possibile, poi va a capo.

	\item \inline{BorderLayout}: Dispone i componenti hai lati o al centro.

	Metodi: \inline{setHgap(), setVgap()}.Modella una griglia flessibile.
\end{itemize}
Le strategie sono componibili tra loro.

Quando si aggiunge un JComponent a un JPanel si può specificare in base al LayoutManager la "modalità".

\textbf{Layout dinamico}: Si ottiene modificando i componenti di un pannello e aggiornandolo con \inline{JPanelObj.validate()}.

\subsection{Eventi}
\inline{EventListener} è una \inline{interface} (implementata come classe anonima) che cattura un'evento d'un compomente "connesso" e lo gestisce.

Per connettere il componenti all'ActionListener.

\oneline{JComponentObj.addActionListener(ActionListenerAnonimusClass);}

Sotto interfacce: \inline{ActionListener, ComponentListener, ContainerListener, FocusListener, ItemListener, KeyListener, MouseListener, WindowListener, TextListener, MouseWheelListener}.

\subsection{MVC}
 Un pattern architetturare del sistema software è generico ma definisce: elementi software, relazioni tra elementi, proprietà degli elmenti e delle relazioni.
 Il prodotto finale sarà facilmente modificabile e controllabile.

 Il pattern architetturare \textbf{MVC (Model View Controller)}:

 \begin{center}
 	\begin{tikzcd}
 		{[View]} \arrow[r, bend right] & {[Controller]} \arrow[r, bend right] \arrow[l, bend right] & {[Model]} \arrow[l, bend right]
 	\end{tikzcd}
 \end{center}

 \begin{itemize}
 	\item \textbf{Model}: Modello OO (dati e logica) del dominio applicativo.
 	\item \textbf{View}: Gestice interazione con l'utente (GUI e notifiche).
 	\item \textbf{Controller}: Gestisce coordinamento fra Model e View intercettando gli eventi di View, comandando il Model e aggiornando la View.
 \end{itemize}

 \begin{center}
	\begin{tikzcd}
		V \arrow[rr, "azioni \ utente"', bend right] &  & C \arrow[rrr, "Metodi \ di \ dominio"] \arrow[ll, "richieste \ valutazione"', bend right] &  &  & M
	\end{tikzcd}
 \end{center}

 \textbf{Linee Guida}: Ogni componente strutturale richiede un interfaccia (ModelInterface, ViewObserver, ViewInteface). Bisogna terenere la massima indipendenza tra i componenti. Testare ogni componente separatamente.

 \begin{center}
 	\begin{tikzcd}
 		{[ViewInteface]}                                      & {[ViewObserver]}                                                        & {[ModelInterface]}                          \\
 		{[ViewClass]} \arrow[u, two heads, dashed] \arrow[ru] & {[ControlClass]} \arrow[lu] \arrow[u, two heads, dashed] \arrow[ru]     & {[ModelClass]} \arrow[u, two heads, dashed] \\
 		& {[Application]} \arrow[lu, dashed] \arrow[u, dashed] \arrow[ru, dashed] &
 	\end{tikzcd}
 \end{center}

\subsubsection{Caricamento risorse e altro}
\begin{itemize}
	\item \inline{getProperty(p : String) : String} della classe  \inline{System} permette di accedere alle proprietà: \inline{file.separator, java.home, user.dir, user.home, user.name}.

	Proprietà di sistema: \inline{java.version, os.arch, os.name, os.version}.

	\item Il locale (lingua, regione, numeri, data, valuta, ...) in java si gestisce con \inline{i18n=international} che può essere localizzato con \inline{l10n=localization}.

	\item \inline{UTF-8 (java), MacRoman, ISO-(OSI-8859-1} sono i ecoding più comuni.

	\item La classe \inline{ClassLoader} secondo \textit{location-independent} carica/legge le risorse dal classpath:
	\begin{itemize}
		\item \inline{ClassLoader.getSystemClassLoader() : ClassLoader} Da l'oggetto responsabile del caricamento di classi e risorse (figlio system class loader).
		\item \inline{ClassLoader.getSystemResourceAsStream("nomeRisorsa") : InputStream} Argomento è il nome non il path.
		\item \inline{ClassLoader.getSystemResource("nomeRisorsa") : URL} Argomento è il nome non il path.
		\item \inline{getResource(String name) : URL}
	\end{itemize}

	\item Le impostazioni untente si salvano in una cartella, \inline{.nomeProgramma}, dell' \textbf{home forlder}. Se non presente si deve inizializzare con quelle di default tramite \inline{getResource()}.

	\item \inline{Apache Maven} definisce lo standard name per le librerie come \textbf{groupId:artifactId:version}.
	\begin{itemize}
		\item \textbf{groupId}: URL invertito che identifica un progetto.
		\item \textbf{artifacId}: Nome in kebab-case per librerie o moduli.
		\item \textbf{version}: Sequenza di numeri e lettere separate da .,-,+ per le librerie.
	\end{itemize}

	Sonatype OSSRH è la repository di librerie esterne (e dipendenze traversali) e proprie.
\end{itemize}

\subsection{JavaFX}
Libreria stand-alone opensource per GUI (Java APIs, FXML e CSS, Graphics API, supporto schermi multi-touch e HI-DPI, interoperabilità Swing).

\bigskip

\begin{itemize}
	\item \textbf{Stage (javafx.stage.Stage)}: Contenitore esterno della GUI (corrisponde JFrame). Sotto classe di \inline{Window}.

	Uno Stage mostra una Scena alla volta. Si imposta con: \inline{Stage#setScene(Scene)}.

	Si mostra con \inline{show()}.
	\item \textbf{Scene (javafx.scene.Scene)}: Contenuto/pagina visualizzabile sullo Stage.

	Contiene il scene graph impostabile con: \inline{Scene#setRoot(Parent)}
\end{itemize}

La classe principale di un'applicazione JavaFX estende \inline{javafx.appplication.Application}. Definisce metodi hook sul ciclo di vita dell'applicazione e in \inline{start(Stage)} si definisce e riceve lo stage primario.

AVVIO: Il main deve essere in una classe separata da quella dell'applicazione JavaFX e contenere \inline{Application.lauch(App.class, args);} con \inline{App} la classe che implementa \inline{Application}.

\bigskip

\textbf{Ciclo vita Applicazione}: avvio thread -> installazione di \inline{App} -> invocazione \inline{init()} poi \inline{start(javafx.stage.Stage)} -> attesa fine \inline{Platform.exit()} e \inline{Platform.isImplicitExit()} -> invocazione \inline{stop()}.

\bigskip

\textbf{Node}: Elemento/Componente (sia aspetto (view) che comportamento (controller)) della scena, con proprietà (ha un id, coordinate locali, classe \inline{Property<T>}) e eventi.

Ordinabili gerarchicamente, sottoclasse \inline{Parent} con \inline{getChildern()}. Ogni scena ha il \textit{root node} relativo alla gerarchia di nodi.

\bigskip

\textbf{Layout}: Contenitore, \inline{Parent}, che regola posizione e dimensione nodi figli:
\begin{itemize}
	\item \textbf{Group}: Applica stesse trasformazioni/effetti all'intero insieme di figli. I figli hanno posizioni fisse (non-resizable).
	\item \textbf{Region}: Classe base per tutti layout general purpose (resizable).

	\inline{GetChildren()} usa \inline{get()} e \inline{addAll()} lavorando con \inline{ObservableList<Node}.

	Forniti metodi d'istanza/statici per il posizionamento contenuti.
\end{itemize}
I \textit{bound} definiscono posizione e dimensione, secondo un \textit{bounding rectangle}, per le Scene/Stage/node.

\bigskip

\textbf{Eventi}: Un \inline{Event} ha una \textit{source}, \textit{target} e \textit{type}. Si consuma con \textbf{consume()} da un event handlers che implementa \inline{handle(T)}. Un nodo gestisce più event handler con \inline{setOn...()}.

\bigskip

\textbf{Concorrenzza}: JFXAT (JavaFX Application Thread) è il thread di gestione della GUI. Con Platform.rumLater(Runnable) si accoda il runnable nella coda degli eventi.

\bigskip

\inline{Screen.getPrimary()} da accesso a \inline{getDpi()}, \inline{getBounds()}, \inline{getVisualBounds()}, \inline{Screen.getScreens()} per gestire lo schermo.

\bigskip

Si può integrare JavaFX in Swing e vice versa medinate \inline{SwingNode} e \inline{JFXPanel} del modulo \inline{javafx.swing} (attenzione a \inline{runLater()} e \inline{invokeLater()}).

\subsubsection{Binding e proprietà}
Collegamento di due proprietà fra loro, in modo unidirezionale o bidirezionale.

Una proprietà JavaFX \inline{Property<T>} è un \inline{ObservableValue<T>}\footnote{Valore ottenibile con \inline{getValue()} a cui possono essere associati dei \inline{ChangeListener} via \inline{remove/addListener}.} scrivibile e collegabile ad'altri osservatori o proprietà:
\begin{itemize}
	\item \inline{bind(observableObj)} Collega unidirezionalmente dalla VEW al Model.

	Per scollegare usare \inline{unbind()}.
	\item \inline{bindBidirectional(other)} Collega bidirezionalmente la VEW al Model.

	Per scollegare usare \inline{unbindBidirectional(other)}.
\end{itemize}
