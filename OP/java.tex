\section{Struttura Programma Java}
Un programma Java è composta da librerie di classi del JDK, Package\footnote{Contenitori, gerarcici tra loro, di una decina di classi di alto livello con scopo comune.} e Moduli\footnote{Insieme di Package costituente un frammento di codice autonomo.}, librerie di esterne e un insieme di classi fondamentali.

La classe cardine di un programma è la class main\footnote{Un main è il punto d'accesso di un programma.}.
\multiline{main}{}{CodiciEsempio/main.java}
Il parametro del main è un array di stringhe che sono i parametri che l'utente può immettere da tastiera quando il programma è lanciato da CLI. Poco usato.

\subsection{Esecuzione Programma}
\begin{enumerate}
	\item Salvare la classe in un file \textbf{"NomeClasse.java"}.
	\item Compilare con \textit{javac NomeFileClasse.java}. Genererà il \textbf{bytecode NomeFileClasse.class} per la JVM.
	\item Esegiure con \textit{java NomeFileClasse}. La JVM cercherà il main da cui partire a eseguire.
\end{enumerate}
Lavorando con più file: si compila tutto con \textit{javac *.java} poi si esegue solo il bytecode contenente la classe main.

\subsection{I package}
Per prassi nella cartella di un progetto, si fa corrispondere hai package auto-costruiti delle directory del file system.

Di default il package di una unità di compilazione\footnote{File.java compilabile atomicamente contenente classi una dopo l'altra.}, ".java", è la root di gerarchia.
Per definire il pakage di appartenenza si specifica a inizio sorgente:

\inline{package <pName>;}

Per poi usare una classe di un package bisogna importarla (non aggiunge codice nell'eseguibile):
\begin{itemize}
	\item \inline{import java...;} importa una singola classe.
	\item \inline{import java...*;} importa l'intero Package.
	\item \inline{import java.lang.*;} importazione di default.
\end{itemize}
Il nome completo di una classe dipende dal Package in cui si trova. Se non si importa bisogna specificare all'uso il nome completo.

\subsubsection{Compilazione ed'esecuzione Avanzata}
Per tenere sorgenti e eseguibili separati, in progetti grandi si dispone la cartella \textit{src} per i sorgenti (.java) e la cartella \textit{bin} per i bytecode (.class).

\oneline{javac -d "<dirExe>" [-cp "<lib1:|;...>"] <.../elencoSorgenti>}

\oneline{java -cp "<dirExe[lib1:|;...]>" <fullyClasseMain>}

\begin{itemize}
	\item \inline{-d} specifica al compilatore la cartella dove creare i .class. Se non già presente la crea.
	\item \inline{-cp} linka le classi dei percorsi specificati (divisi da : o ;) al classpath\footnote{Sottopercorso (insieme ordinato) di cartelle che corrisponde al percorso del package dichiarato per la classe corrispondente. Il classpath di default è il JRE (Java Runtime Environment).}.
	\item La JVM si aspetta il FQCN (Fully-Qualified Class Name).
\end{itemize}

\subsubsection{Gradle}
Build system ibrido composto da:
\begin{itemize}
	\item \textbf{Progetto} Cartella contenente i file \textit{build.gradle.kts} e/o \textit{settings.gradle.kts} (build files).
	\begin{enumerate}
		\item Il build contiene la logica di costruzione del software.

		\oneline{plugins\{java\}}

		Io creo \textit{src/main/java} per i .java e sarà creato \textit{build/classes/java/main} per i .class.
		\item Il settings contine la personalizzazione, come il nome del progetto.

		\oneline{rootProject.name="..."}
	\end{enumerate}
	\item \textbf{Plugin} Sofware contenente \textit{task} pronti all'uso, come per java.
	\item \textbf{Task} Singola operazione atomica del processo di costrutzione del software. Una esecuzione gradle richiede una o più task di cui sono automaticamente dedotte le dipendenze.

	Comandi: gradle tasks, gradle tasks --all, gradle compileJava, gradle clean.
\end{itemize}
L'esecuzione è delegata al compilatore del linguaggio specifico.

\textbf{Wrapper}: sofware scarica gradle e lo usa per creare il sofware.
File del wrapper: gradle/wrapper/gradle-wrapper.jar (wrapper in s'è), gradle/wrapper/gradle-wrapper.properties (versione), ./gradlew oppure gradlew.bat (eseguono il wrapper).

Per compilare:
\oneline{./gradlew compileJava}



\subsection{Convenzioni}
\begin{itemize}
	\item Linee max 90 caratteri e indenzazione 2-4 caratteri.
	\item Una sola istruzione per riga e quindi si definisce una sola variabile per riga, quando necessario, sempre inizializzata.
	\item Apertura "\{" a fine riga della dichiarazione e chiusura "\}" in linea a dove inizia la riga di apertura.
	\item Condice senza righe vuote di separazione a meno di metodi/costruttori.
	\item Non usare assegnamenti dentro espressioni e usare parentesi solo in espressioni non banali.
	\item Nomi classi e interfacce in "PascalCase". Nomi metodi, campi, variabili in "camelCase" e costanti in "SNAKE\_CASE". Nomi di package in minuscolo con numeri e senza "\_".
	\bigskip
	\item I metodi che returnano, senza parametri, si chiamano \inline{get...} oppure \inline{is/has...} se return boolean.
	\item I metodi che returnano void, e accettano parametri, si chiamano \inline{set...}.
\end{itemize}