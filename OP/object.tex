\section{Struttura Programma Java}
Un programma Java è composta da librerie di classi del JDK, Package\footnote{Contenitori, gerarcici tra loro, di una decina di classi di alto livello con scopo comune.} e Moduli\footnote{Insieme di Package costituente un frammento di codice autonomo.}, librerie di esterne e un insieme di classi fondamentali.

La classe cardine di un programma è la class main\footnote{Un main è il punto d'accesso di un programma.}.
\multiline{main}{}{CodiciEsempio/main.java}
Il parametro del main è un array di stringhe che sono i parametri che l'utente può immettere da tastiera quando il programma è lanciato da CLI. Poco usato.

\subsection{Esecuzione Programma}
\begin{enumerate}
	\item Salvare la classe in un file \textbf{"NomeClasse.java"}.
	\item Compilare con \textit{javac NomeFileClasse.java}. Genererà il \textbf{bytecode NomeFileClasse.class} per la JVM.
	\item Esegiure con \textit{java NomeFileClasse}. La JVM cercherà il main da cui partire a eseguire.
\end{enumerate}
Lavorando con più file: si compila tutto con \textit{javac *.java} poi si esegue solo il bytecode contenente la classe main.

\subsection{I package}
Per prassi nella cartella di un progetto, si fa corrispondere hai package auto-costruiti delle directory del file system.

Di default il package di una unità di compilazione\footnote{File.java compilabile atomicamente contenente classi una dopo l'altra.}, ".java", è la root di gerarchia.
Per definire il pakage di appartenenza si specifica a inizio sorgente:

\inline{package pname;}

Per poi usare una classe di un package bisogna importarla (non aggiunge codice nell'eseguibile):
\begin{itemize}
	\item \inline{import java...;} importa una singola classe.
	\item \inline{import java...*;} importa l'intero Package.
	\item \inline{import java.lang.*;} importazione di default.
\end{itemize}
Il nome completo di una classe dipende dal Package in cui si trova. Se non si importa bisogna specificare all'uso il nome completo.

\subsubsection{Compilazione ed'esecuzione Avanzata}
Per tenere sorgenti e eseguibili separati, in progetti grandi si dispone la cartella \textit{src} per i sorgenti (.java) e la cartella \textit{bin} per i bytecode (.class).

\oneline{javac -d "<dirExe>" [-cp "<lib1:|;...>"] <.../elencoSorgenti>}

\oneline{java -cp "<dirExe[lib1:|;...]>" <fullyClasseMain>}

\begin{itemize}
	\item \inline{-d} specifica al compilatore la cartella dove creare i .class. Se non già presente la crea.
	\item \inline{-cp} linka le classi dei percorsi specificati (divisi da : o ;) al classpath\footnote{Sottopercorso (insieme ordinato) di cartelle che corrisponde al percorso del package dichiarato per la classe corrispondente. Il classpath di default è il JRE (Java Runtime Environment).}.
	\item La JVM si aspetta il FQCN (Fully-Qualified Class Name).
\end{itemize}

\subsection{Convenzioni}
\begin{itemize}
	\item Linee max 90 caratteri e indenzazione 2-4 caratteri.
	\item Una sola istruzione per riga e quindi si definisce una sola variabile per riga, quando necessario, sempre inizializzata.
	\item Apertura "\{" a fine riga della dichiarazione e chiusura "\}" in linea a dove inizia la riga di apertura.
	\item Condice senza righe vuote di separazione a meno di metodi/costruttori.
	\item Non usare assegnamenti dentro espressioni e usare parentesi solo in espressioni non banali.
	\item Nomi classi e interfacce in "PascalCase". Nomi metodi, campi, variabili in "camelCase" e costanti in "SNAKE\_CASE". Nomi di package in minuscolo con numeri e senza "\_".
	\bigskip
	\item I metodi che returnano, senza parametri, si chiamano \inline{get...} oppure \inline{is/has...} se return boolean.
	\item I metodi che returnano void, e accettano parametri, si chiamano \inline{set...}.
\end{itemize}

\subsubsection{I Commenti}
Oltre a \inline{//... e /*...*/} in java abbiamo \inline{/** ... */} un commento multi linea usato per generare documentazione.


\section{(Almost) Everything is an object}
Le variabili, contenitori con nomi, ora non denotano solo valori numerici (come in C), ma anche veri e propri oggetti irriducibili.

Non ci sono meccanismi per controllo diretto memoria. Le variabili sono nomi "locali" con riferimenti ad'\textit{oggetti} e non maschere di indirizzi in memoria a cui accedere direttamente.

Le variabili posso essere di tipo \textit{Java Types} quindi classi predefinite e autoimplementate oppure \textit{tipi primitivi}.

Visibilità legata al blocco di definizione.
Variabili non inizializzate sono inutilizzabili.

\subsection{Stack e Heap}
Gli oggetti sono memorizzati nell'\textbf{heap}. Tutte le variabili sono memorizzate nello \textbf{stack}.

Le variabili di tipo primitivo contengono direttamente il valore. Le variabili tipo classe contengono il riferimento dell'oggetto oppure null.

Nota: Uno stesso oggetto può essere puntato da variabili che si riferiscono alla stessa identità.

\subsection{Tipi Primitivi}
Ripasso: Un tipo classifica valori/oggetti tramite un nome, set valori, operatori.

I tipi atomici \textbf{signed} del C si sono mantenuti (non conveniva trattarli come oggetti) definendo un unica interpretazione:
\begin{center}
	\begin{tabular}{llll}
		\hline
		Tipi  primitivi & Dimensione & Minimo & Massimo \\
		\hline
		boolean & -- & -- & -- \\
		char & 16bits & Unicode 0 & Unicode $2^{16}-1$ \\
		byte & 8bits & -128 & +127 \\
		short & 16bits & $-2^{15}$ & $-2^{15}-1$ \\
		int & 32bits & $-2^{31}$& $+2^{31}-1$ \\
		long & 64bits  & $-2^{63}$& $-2^{63}-1$\\
		float & 32bits & IEEE754 & IEEE754 \\
		double & 64bits & IEEE754 & IEEE754 \\
		\hline
	\end{tabular}

	{\tiny Le librerie \textit{BigDecimal, BigInteger} gestiscono numeri di dimensione/precisione arbitraria.}
\end{center}

\textbf{typing statico}: espressioni tipo noto al compilatore, vantaggio intercettazione errori.

\textbf{Nota:} Uso memoria non dato a sapere al programmatore.

\subsubsection{Boolean}
Introdotto come tipo risultato delle espressioni e condizioni.
\begin{itemize}
	\item \textbf{Valori} true, false.
	\item \textbf{Operatori Unari} \inline{! (not)}. Peratori binari: \inline{\& (and), | (or), \^ (xor), \&\& (and-C), || (or-c)}\footnote{\inline{& e |} valutano sempre primo e secondo termine, essendo pensati per operazioni bit a bit mentre \inline{&& e ||} valotano il secondo operatore solo se necessario.}.
	\item \textbf{Operatori confronto numerici} \inline{<, >, <=, >=}.
	\item \textbf{Operatori di uguaglianza} \inline{==, !=}. Con gli oggett di base confronta i riferimenti.
	\item \textbf{Operatore ternario} \inline{<eb> ? e1 : e2}. restituisce e1 se eb è true, altrimenti restituisce e2. e1 e e2 espressioni dello stesso tipo.
\end{itemize}

\subsubsection{Caratteri}
Rappresentazione \inline{'carattere'} o \inline{'\u<0-65535>'}. Formato ASCII o UTF16 (16bit). I caratteri d'escape si fanno \inline{'\\<specificatore>'}.

\subsubsection{Interi}
\begin{itemize}
	\item \textbf{Codificati} in complemento a 2.
	\item \textbf{Operatori} \inline{+ ,-, *, /, \%, + e - unari, \&, |, ~, <<, >>, >>>}. Output stesso tipo Input.
	\item \textbf{Rappresentabili} in codifica decimale (1\_000\_000), ottale (0...), esadecimale (0x...).
	\item \textbf{Input tastiera} default int (più usato e efficente). Se voglio un long va aggiunta una "l" dopo il numero.
\end{itemize}

\subsubsection{Virgola mobile}
\begin{itemize}
	\item \textbf{Operatori} \inline{+ ,-, *, /, \%, + e -} unari.
	\item \textbf{Codificati} in IEEE754.
	\item \textbf{Rappresentabili} in codifica decimale o scientifica.
	\item \textbf{Input tastiera} default double. Se voglio un float (più efficente) va aggiunta una "f" dopo il numero.
\end{itemize}
\textbf{Ricorda}: IEEE754 ha errori di precisione che portano all'approssimazione dei risultati.

\subsection{Conversioni}
\begin{itemize}
	\item \textbf{Implicita} automaticamente applicata nelle esperessioni e nell'assegnamento portando tutti tipi a quello più "generale" presente nell'espressione. Detta \textit{coercizione}.

	$byte\to short \to int \to long \to float \to double$
	\item \textbf{Esplicito} fatto con operatore di casting: \inline{...=(<tipo>)<espressione>;}. Può causare perdità di informazioni.
\end{itemize}

\subsection{Array}
Oggetti (variabili hanno riferimento nello heap) di lunghezza esplicita e acessibile, inacessibile fuori dai limiti (errore esecuzione), mutabili. Indirizzi elementi [0, lunghezza-1].

Sintassi:
\begin{itemize}
	\item \inline{<tipo>[] <nome> = new <tipo>[] \{v1,...,vn\};}
	\item \inline{<tipo>[] <nome> = new <tipo>[<dim>];}. Elementi inizializzati a valore default tipo (false, 0, null).
	\item \inline{<tipo>[] <nome> = \{v1,...,vn\};}
\end{itemize}

Note: Si possono fare array di array. Gli array di oggetti sono oggetti con puntatori ad'altri oggetti.

Accesso a variabile \inline{... <nome>[<ind>] ...}.

Per sapere la lunghezza dell'array \inline{<nome>.length}.

\subsubsection{Foreach}
Astazione \inline{for} in sola \textbf{lettura}, utile quando non importa ordine scorrimento elementi collezione e valore indice.

\oneline{for(final<tipo> <v>: <e>)}

\begin{itemize}
	\item \inline{v} è variabile del tipo indicato che vale via via ogni elemento della colezzione.
	\item \inline{e} è un espressione che restituisce una collezione di elementi del tipo indicato.
	\item Si può esplicitare \inline{final}, anche se non servirebbe, perchè il foreach crea una nuova variabile a ogni iterazione in realtà.
\end{itemize}