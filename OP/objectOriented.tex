\section{Fasi sviluppo Sofware}
Un Programma (algoritmo) risolve una classe di problemi.

Un Sistema sofware fornisce varie funzionalità grazie alla cooperazione di componenti di diversa natura.

Fasi processo sviluppo:
\begin{enumerate}
	\item \textbf{Analisi}: che fare?. Definisce precisamente il problema, ingegnerizza i requisiti, modellizza il dominio.

	Sotto fase è interazioni col committente produce un contratto (aspetto e funzionalità).

	Un analisi è corretta se persone diverse giungono alla stessa soluzione.
	\item \textbf{Design}: come farlo? Definisce struttura software/soluzione.

	\begin{itemize}
		\item Design architetturale: Progettazione struttura complessiva dei moduli e macro relazioni.

		Come per OPP? Unico diagramma di 5-12 interfacce non isolate, accompagnato da prosa dei ruoli e relazioni.
		Seguendo Pattern MVC (thread vanno in C).
		\item Progetto di dettaglio: Progettazione più precisa forma moduli e relazioni più importanti.

		Ulteriori UML documentano progettazioni di dettaglio.
	\end{itemize}

	\item \textbf{Implementazione/codifica}: Quale algoritmo? Si realizza il sofware scegliendo le tecnologie adeguate.
	\item \textbf{Post-coficia}: Collaudo, Manutenzione, Deployment.

	Può impiegare fino 70\% se fasi precedenti fatte male/sbrigativamente (riscio Software crisis).
\end{enumerate}
Fasi 1-2 fatte dai senior e fase 3 junior (2-3 oggi unificate).
Tutte fasi fattibili dalla stessa persona.

Approcci di sviluppo:
\begin{itemize}
	\item \textbf{Cascata}: Fasi eseguite in ordine temporale.
	\item \textbf{Spirale}: Fasi svolte in ordine ciclicamente.
	\item \textbf{Fontata}: Si oscilla temporaneamente tra fase successiva/precedente.
	\item \textbf{Agile}.
\end{itemize}

Per piccoli progetti: Porre obbietivi intermedi incrementali (prototipo, avanzato, definitivo), con approccio a cascata per ognuno.

\subsection{Problem space vs Solution space}
\begin{itemize}
	\item Problem space sono le entità/relazioni/processi del mondo reale che formano il problema.
	\item Solution space sono le entità/relazioni/processi nel mondo artificiale (espresse nel linguaggio di programmazione).
\end{itemize}


Per passare dal Problem space al Solution solution si esegue un "mapping" che più semplice è meglio ho fatto le \textbf{astrazioni}\footnote{Strumento che semplifica sistemi informatici ma anche del mondo reale evidenziando "la parte importante". Si possono fare più livelli di astrazione.}.

I linguaggi di programmazione attuano l'astrazione coi loro costrutti, più o meno performanti, che rendono il mapping più o meno facile.
I linguaggi moderni hanno un livello d'astrazione lontano dall'Hardware, i suoi problemi e la gestione della memoria.

\subsection{Programmazione ad oggetti (OOP)}
\textbf{Vantaggi:} poche astrazioni chiave, mapping ottimo e semplice, estensibilità e riutilizzo, librerie auto costruite, C-like, esecuzione efficente. \textbf{Critiche:} necessaria disciplina.

\bigskip

\colTwo{\textbf{Classe:} Descrizione comportamento e forma oggetti. Indica come comunicare con i suoi oggetti, con messaggi che modificano stato e comportamento.}{\textbf{Oggetto:} Entità (istanza di classe) manipolabile, con memoria, che comunicano tramite le loro operazioni descritte dalla classe di appartenenza.}{45}{45}

Oggetti della stessa classe hanno comportamento e forma indentica, sono detti simili.
Un oggetto non cambia mai classe, semmai si elimina e sene crea il sostituto.
Nota: L'approccio OOP è usato anche in UML.

\bigskip

\textbf{Com'è fatto un buon oggetto:}
Un oggetto ha un interfaccia\footnote{Insieme dei metodi definiti dall'interfaccia con cui l'oggetto riceve messaggi.}, deve fornire un servizio, deve nascondere le implementazioni (riutilizzabili) e l'intero oggetto deve essere riutilizzabile tramite ereditarietà. Precisazioni:
\begin{itemize}
	\item Un oggetto fornisce un \textbf{sotto-servizio} dell'intero programma\footnote{Set di oggetti che si comunicano cosa fare.} (principio decomposizione). Linne giuda: 1 oggetto senza servizio si elimina, 2 oggetto con più servizi si divide.

	\item L'implementazione di un oggetto (logiche interne) devono essere note solo al creatore della classe (Information hidding), cosi facendo l'utilizzatore è tutelato, da modifiche interne, avendo una piccola visione del tutto. \textit{less is more}.

	\item Il creatore e l'utilizzatore riutilizzano le classi con gli approcci:
	\begin{enumerate}
		\item \textbf{has-a} (composizione), classe costituita da altre classi (oggetto ha come campi altri oggetti). Approccio dinamico, occultabile.
		\item \textbf{is-a} (ereditarietà), classe estende servizi di un'altra classe (oggetto ha campi/metodi di altri oggetti).
	\end{enumerate}
\end{itemize}

\section{Perchè Java?}
\begin{itemize}
	\item \textbf{Write once run everywhere}, eseguibile uvunque senza ricompilazione grazie JVM (HardWare virtuale, a stack) che processa un codice specifico "byte code", creando il corrispettivo eseguibile per ogni pc/os. Meno prestante.

	\item \textbf{Keep it simple, stupid}, in teoria non in pratica.
\end{itemize}

\subsection{Elementi fondamentali}
\colTwo{\textbf{Espressione}: fornisce un risulato, riusabile ove si attende un valore.}{\textbf{Comando}: istruzione da terminare con ";", non componibile con altre}{45}{45}

Alcune parole chiave del linguaggio: \inline{for, while, do, switch, if, break, continue, return, var, ecc}.

\subsection{Differenze con C}
\begin{itemize}
	\item Condizioni di \inline{if, for, while, do} restituiscono \inline{boolean}.

	\item Nel \inline{for} è possibile dichiare le variabili contatore (visibili solo internamente).

	\inline{for (<tipo> <c1>,...; <condizoneBoolean>, <modificaC1>,...) \{...\}}

	\item Java da \inline{unreachable statement, variable may not have been initialised, missing return statemet,ecc} come errori, C solo come warning. Approccio più "rigido" ma anche più "corretto".
\end{itemize}

\subsection{Gestione Oggetti in memoria}
Alla creazione di un oggetto, la \inline{new} chiama il gestore della memoria, si calcola la dimensine della memoria da allocare, si alloca, si inizializza e si restituisce il riferimento alla variabile.

La memoria occupata da un oggetto, non si sa com'è organizzata, ma contiene i campi non statici e il riferimento alla classe con la tabella dei metodi. Gli elementi statici sono allocati in una sezione dedicata.

Il \textbf{garbage collector} (componente della JVM) dealloca automaticamente memoria heap non più utilizzata direttamente o indirettamente. Un'oggetto continua a esistere dopo la fine esecuzione dello scope di una variabile che gli fa riferimento.