\section{OOP2.0}
Nella OOP1.0 abbiamo il riuso per composizione, estensione, poliformismo inclusivo (subtyping).

La OOP2.0 aggiunge il poliformismo parametrico (generics), ???, con lo scopo di dare maggiore controllo al programmatore e espressività al linguaggio JAVA.

\begin{center}
	\begin{tikzcd}
		{[.java]} \arrow[rr, "Compilatore"] \arrow[rr, "JavaNew \to JavaVintage"', dotted, bend right] &  & {[.class]} \arrow[rr, "JVM"] &  & {[.exe]}
	\end{tikzcd}
\end{center}

Il compilatore risolve i costrutti della OOP2.0 trasformandoli in costrutti della OOP1.0 lasciando la JVM invariata.

\subsection{Generics}
\colTwo{\textbf{Scopo}: Creare funzionalità di lavorare uniformemente su oggetti indipendentemente dal loro tipo che diventa un parametro della funzionalità.}{\textbf{Vantaggio}: Fattorizzare, tramite astrazione, soluzioni/classi ricorrenti altamente simili in una unica soluzione/classe riusabile.}{45}{45}

Concetti chiave:
\begin{itemize}
	\item La \textbf{type-variable}, solitamente "X", è una variabile che contiene il tipo dell'oggetto a run-time.
	\item La type-variable è usabile ogni qualvolta si potrebbe scrivere un tipo.
	\item Possono esserci più type-variable.
	\item Tipi primiti non accettati, usare i Wrapper automaticamente risolti dall'autoboxing.
	\item Non passare tutti type-variabile lato utente è errrore.
\end{itemize}

\multiline{}{}{CodiciEsempio/Generici.java}
\textbf{Inferenza dei parametri}: Nella \inline{new} i type-variabile si omettono lasciando il \textit{diamond symbol} "$<>$". Alternativa usare la \inline{var}. In rari casi entrambi.

\bigskip

Per creare contratti uniformi si fanno interfacce generiche:

\oneline{... interface <nomeInterfaccia><X [, Y, ...] \{...\}}

Le type-variable sono usate nei metodi defini e le classi implementative le deve istanziare.

\bigskip

Metodi che lavorano e restituiscono qualsiasi tipo:

\oneline{def:... <X [, Y, ...]> <tipoRitorno> <nomeMetodo>(<parametri>) \{...\}}

\oneline{call:... <X, [Y, ...]><nomeMetodo>(<parametri>)...}

Inferiti automatica alla chiamata (non serve diamond symbol).

\subsubsection{Problema type-erasure}
Il compilatore, in fase \textit{erasure}, sostituisce i generics usando il subtyping di object e facendo upcast implicito nelle classi che diventano monomorfiche, mentre lato utente usa autoboxing e downcast esplicito.

Limitazioni implementative:
\begin{itemize}
	\item Non si possono istanziare oggetti (\inline{new}) di tipo type-variabile.
	\item Non è usabile \inline{instanceof type-variabile | nomeClasse<X>}.
	\item Il downcast esplicito da unchecked warning\footnote{Non rompe il programma nel punto del warning ma lo diffonde altrove nel codice dove prima o poi si romperà.}.
	\item Non posso fare array di generics. Vanno fatti array di \inline{object} con i dovuti cast oppure vanno usate le liste.
\end{itemize}

\subsection{Wildcards}
Le whidcards (poliformismo vincolare) permettono di esprimere un insieme di tipi accettati dai parametri di metodo che usa generics.

Permettono di usare oltre ai metodi di Object anche quelli delle classi indicate.

\oneline{<tipo> <nomeMetodo>(Tipo<? extends | super tipoRiferimento> nome,...) \{...\}}

\begin{itemize}
	\item \textbf{extends X}: Bounded covariante. Accetta i sotto tipi di X oltre a X.

	Non usare metodi set (read only).
	\item \textbf{super X}: Boundend controvariante. Accetta i sovra tipi di X oltre a X.

	Non usare metodi get (write only).
	\item Solo \inline{?}, Unbounded, indica qualsiasi type-variabile. Come dire \inline{? extends Object}. Da un codice leggero.
\end{itemize}

\textbf{Importante}: Se due tipi sono sostituibili (covatianza e controvarianca) tra loro non è detto che sempre una classe generics che li implementa entrambi sia sostituibile (Unsafety).
Gli array, simili a un tipo generic, sono unsafety perchè permettono covarianza.

Le wildcards possono essere usate insieme ai generics.

\subsection{Classi innestate stastiche}
Dentro una classe\textbar inerfaccia A outer si innestra la definizione d'una classe\textbar inerfaccia B static nested.

\multiline{}{}{CodiciEsempio/staticNested.java}

Precisazioni:
\begin{itemize}
	\item Esternamente ad'A, B è un tipo richiamabile via A, \textbf{Outer.StaticNested}, secondo il modificatore d'accesso.
	\item Internamente ad'A, B è accessibile direttamente con StaticNested.
	\item Outer e StaticNested si vedono reciprocamente i membri \inline{private}\footnote{Vero significato di \inline{private} è "privato a livello della outerclass più esterna".}.
	\item Se B è classe è instanziabile (\inline{new}).
	\item Il nesting può essere multiplo e/o multilivello.
	\item Per le interfacce innestate il \inline{public static} è implicito.
\end{itemize}

Approcci:
\begin{enumerate}
	\item Outer è la classe astratta e le StaticNested pubbliche sono le implementazioni.
	\item StaticNested privata per sotto-comportamenti (implementaizone interfaccie o estensione classe) di Outer.
	\item StaticNested sono sotto stati dell'Outer non usabili indipendentemente.
\end{enumerate}

\subsection{Inner Class}
Dentro una classe A outer si inserisce la definizione d'una classe B inner (membro non-statico).

\multiline{}{}{CodiciEsempio/innerClass.java}

Precisazioni:
\begin{itemize}
	\item Inner si richiama su un instanza di Outer (enclosing instance), \textbf{Outer.InnerClass}, secondo il modificatore d'accesso.
	\item Un oggetto Inner si crea da un'istanza di Outer, \textbf{... = OuterObj.new Inner(...);}, secondo il modificatore d'accesso.

	Dentro Outer si fa \textbf{... = this.new Inner(...);}.
	\item Inner accede al enclosing instance con \inline{Outher.this}.
\end{itemize}

Approccio: preferibile a classi innestate statiche quando \inline{private}.

\subsubsection{Local Class}
Dentro un metodo d'una classe A Outer si inserisce la definizione d'una classe B local class (Inne Class di fatto).

\multiline{}{}{CodiciEsempio/localClass.java}

Può usare direttamente (senza \inline{this}) variabili final/di fatto final del metodo.

Approccio: Quando ho bisogno della classe solo dentro un metodo.

\subsubsection{Classi anonime}
Classi senza nome e costruttori creta al volo (Local Class di fatto) e da lì creta al volo un'istanza.

\multiline{}{}{CodiciEsempio/classiAnonime.java}

\begin{itemize}
	\item Il metodo "contenitore" restituisce come tipo la classe anonima.
	\item Può usare direttamente (senza \inline{this}) campi dell'Outer class.
	\item Se vuole implementare un'interfaccia si fa:

	\oneline{new NomeInterfaccia(<parametri>) { <implementazione> }}
\end{itemize}

Approccio: Utile per implementare interfacce e quando si deve creare un solo oggetto.

\subsection{Lambda expression}
Funzione anonima con accesso a scope locale (non viene creato un \texttt{.class}). Prende 0, 1, più input e restituisce \inline{void} o un valore.

\textbf{Dove usarla?} Dove ci si aspetta un'oggetto che implementa un'interfaccia funzionale è usabile una lambda come valore/oggetto.

\oneline{(T1 x1,..., Tn xn) -> {<body>}}

\oneline{(T1 x1,..., Tn xn) -> <exp>}

\oneline{(x1,..., xn) -> {<body>}}

\oneline{(x1,...,xn) -> <exp>}

\oneline{() -> <exp>}

\oneline{x -> <exp>}

\subsubsection{Method reference}
Rappresentano lambda che chiamano solamente un metodo (input=inputMetodo, output=ouputMetodo). Va specificato solo il nome del metodo.
\begin{itemize}
	\item \oneline{<class>::<static-method>} Metodo statico chiamato da classe.

	\item \oneline{<obj>::<method>}	Metodo non statico chiamato da oggetto.

	\item \oneline{<class>::<instance-method>} Metodo non statico chiamato da oggetto passato come primo parametro.

	\item \oneline{<class>::new} Nuovo oggetto di classe indicata.
\end{itemize}

\subsubsection{Classe Optional}
Classe Wrapper di T da usare ove ci si attende opzionalmente un oggetto di tipo T (collezione di 0 o 1 elementi).
\begin{itemize}
	\item \inline{Optional.empty()} Per impostare a 0 elementi. Usarlo per inizializzare campi potenzialmente nulli.

	\item \inline{Optional.of(...)} Per impostare a un elemnto.

	\item \inline{Optional.ofNullable(...)} Per impostare a un elemnto che potrebbe essere null.

	\item \oneline{isPresent()} Dice se è presente o meno un elemento non null.

	\item \oneline{ifPresent(...)} Esegue se è presente l'elemento.

	\item \oneline{orElse(...)} Esegue se non è presente l'elemento.

	\item \oneline{get()} Per ottenere l'elemento o l'eccezione uncheked NoSuchElementException o \inline{null}.
\end{itemize}

Usare \inline{Objects.requireNonNull(...)} per controllo su argomenti in ingresso.

\subsubsection{Switch expressions}
Variante dello \inline{switch} statement usabile come espressione con output il risultato del case eseguito.

\multiline{}{}{CodiciEsempio/switch.java}

\textbf{pattern matching}: Se \inline{var} è istanza del tipo specificato nel \inline{case} con \inline{tipo var}, posso usare \inline{var} nel corpo del \inline{case} riferendomi a \inline{var}.

\subsection{Stream}
\inline{java.util.stream} fornisce un approccio a flusso sequenziale di dati omogenei, usabili una volta sola, da cui si ottiene un'infomazione complessiva/aggregata.

Interfaccie: \inline{Stream<T>}, \inline{BaseStream<X, B>}.

Pipeline:
\begin{enumerate}
	\item Sorgente (Collection, array, I/O, funzione generatrice).
	\begin{itemize}
		\item \inline{Stream.empty()}
		\item \inline{Stream.of(...)}
		\item \inline{Stream.iterate(seedPartenza, UnaryOperatorIncremento)}
		\item \inline{Stream.generate(Supplier)} Genera infini valori in base una regola specificata.
		\item \inline{Stream.concat(Stream1, Stream2)}
		\item \inline{collectionObj.stream()|parallelStream()}
	\end{itemize}
	\item Sequenza trasformazioni.
	\begin{itemize}
		\item \inline{filter(Predicate)} Fa passare solo elementi rispettano condizione.
		\item \inline{map(Function)} Trasforma/sostituisce ogni elemento in/con un'altro.
		\item \inline{flatMap(Function)} Trasforma ogni elemento in uno Stream e li unisce tutti.
		\item \inline{distinct()} Elimina le ripetizioni d'elementi (non lazy).
		\item \inline{sorted([Comparator])} Ordina crescentemente o secondo una condizione specifica (non lazy).
		\item \inline{peek(Consumer)} Esegue un azione per ogni elemento.
		\item \inline{limit(long)} Limita lo Stream a un numero prefissato di elementi.
		\item \inline{skip(long)} Salta i primi n elementi.
	\end{itemize}
	\item Terminatore che aggrega i dati in un valore, Collection, array, Iteratore.
	\begin{itemize}
		\item \inline{forEach(Consumer)} Esegue un'operazione per ogni elemento.
		\item \inline{reduce(binaryOperator)} Esegue un'operazione con tutti i valori e restituisce un'unico valore.
		\item \inline{foreEachOrdered(Consumer)} Ordina gli elementi e poi esegue per ognuno un'operazione (non lazy).
		\item \inline{max(Comparator)} Da il massimo elemento secondo un criterio.
		\item \inline{min(Comparator)} Da il minimo elemento secondo un criterio.
		\item \inline{count()} Restituisce il numero di elementi ottenuti.
		\item \inline{anyMatch(Predicate)} Dice se un elemento è presente o no.
		\item \inline{findAny()} Restituisce uno qualsiasi degli elementi.
		\item \inline{collect(Collect)} Dice allo stream come raccogliere gli elementi.
	\end{itemize}
\end{enumerate}

Caratteristiche:
\begin{itemize}
	\item \textbf{Dichiavarivo}: Non indica passo-passo come l'informazione viene processata.

	\item \textbf{Lazy}: Dati procesati all'occorrenza e non sono memorizzati tutti assieme quando si può (no collezioni temporanee).

	\item \textbf{Parallelizzabile}: Operazioni Automaticamente computabili separatamente da un set di Thread.
\end{itemize}

Nota: Stream di tipi specifici sono più performanti, ma non hanno tutte le funzionalità di uno Stream generico.