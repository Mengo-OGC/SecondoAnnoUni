\section{OOP2.0}
Nella OOP1.0 abbiamo il riuso per composizione, estensione, poliformismo inclusivo (subtyping).

La OOP2.0 aggiunge il poliformismo parametrico (generics), ???, con lo scopo di dare maggiore controllo al programmatore e espressività al linguaggio JAVA.

\begin{center}
	\begin{tikzcd}
		{[.java]} \arrow[rr, "Compilatore"] \arrow[rr, "JavaNew \to JavaVintage"', dotted, bend right] &  & {[.class]} \arrow[rr, "JVM"] &  & {[.exe]}
	\end{tikzcd}
\end{center}

Il compilatore risolve i costrutti della OOP2.0 trasformandoli in costrutti della OOP1.0 lasciando la JVM invariata.

\subsection{Generics}
\colTwo{\textbf{Scopo}: Creare funzionalità di lavorare uniformemente su oggetti indipendentemente dal loro tipo che diventa un parametro della funzionalità.}{\textbf{Vantaggio}: Fattorizzare, tramite astrazione, soluzioni/classi ricorrenti altamente simili in una unica soluzione/classe riusabile.}{45}{45}

Concetti chiave:
\begin{itemize}
	\item La \textbf{type-variable}, solitamente "X", è una variabile che contiene il tipo dell'oggetto a run-time.
	\item La type-variable è usabile ogni qualvolta si potrebbe scrivere un tipo.
	\item Possono esserci più type-variable.
	\item Tipi primiti non accettati, usare i Wrapper automaticamente risolti dall'autoboxing.
	\item Non passare tutti type-variabile lato utente è errrore.
\end{itemize}

\multiline{}{}{CodiciEsempio/Generici.java}
\textbf{Inferenza dei parametri}: Nella \inline{new} i type-variabile si omettono lasciando il \textit{diamond symbol} "$<>$". Alternativa usare la \inline{var}. In rari casi entrambi.

\bigskip

Per creare contratti uniformi si fanno interfacce generiche:

\oneline{... interface <nomeInterfaccia><X [, Y, ...] \{...\}}

Le type-variable sono usate nei metodi defini e le classi implementative le deve istanziare.

\bigskip

Metodi che lavorano e restituiscono qualsiasi tipo:

\oneline{def:... <X [, Y, ...]> <tipoRitorno> <nomeMetodo>(<parametri>) \{...\}}

\oneline{call:... <X, [Y, ...]><nomeMetodo>(<parametri>)...}

Inferiti automatica alla chiamata (non serve diamond symbol).

\subsubsection{Problema type-erasure}
Il compilatore, in fase \textit{erasure}, sostituisce i generics usando il subtyping di object e facendo upcast implicito nelle classi che diventano monomorfiche, mentre lato utente usa autoboxing e downcast esplicito.

Limitazioni implementative:
\begin{itemize}
	\item Non si possono istanziare oggetti (\inline{new}) di tipo type-variabile.
	\item Non è usabile \inline{instanceof type-variabile | nomeClasse<X>}.
	\item Il downcast esplicito da unchecked warning\footnote{Non rompe il programma nel punto del warning ma lo diffonde altrove nel codice dove prima o poi si romperà.}.
	\item Non posso fare array di generics. Vanno fatti array di \inline{object} con i dovuti cast oppure vanno usate le liste.
\end{itemize}

\subsection{Wildcards}
Le whidcards (poliformismo vincolare) permettono di esprimere un insieme di tipi accettati dai parametri di metodo che usa generics.

Permettono di usare oltre ai metodi di Object anche quelli delle classi indicate.

\oneline{<tipo> <nomeMetodo>(Tipo<? extends | super tipoRiferimento> nome,...) \{...\}}

\begin{itemize}
	\item \textbf{extends X}: Bounded covariante. Accetta i sotto tipi di X oltre a X.

	Non usare metodi set (read only).
	\item \textbf{super X}: Boundend controvariante. Accetta i sovra tipi di X oltre a X.

	Non usare metodi get (write only).
	\item Solo \inline{?}, Unbounded, indica qualsiasi type-variabile. Come dire \inline{? extends Object}. Da un codice leggero.
\end{itemize}

\textbf{Importante}: Se due tipi sono sostituibili (covatianza e controvarianca) tra loro non è detto che sempre una classe generics che li implementa entrambi sia sostituibile (Unsafety).
Gli array, simili a un tipo generic, sono unsafety perchè permettono covarianza.

Le wildcards possono essere usate insieme ai generics.

\subsection{Classi innestate stastiche}
Dentro una classe\textbar inerfaccia A outer si innestra la definizione d'una classe\textbar inerfaccia B static nested.

\multiline{}{}{CodiciEsempio/staticNested.java}

Precisazioni:
\begin{itemize}
	\item Esternamente ad'A, B è un tipo richiamabile via A, \textbf{Outer.StaticNested}, secondo il modificatore d'accesso.
	\item Internamente ad'A, B è accessibile direttamente con StaticNested.
	\item Outer e StaticNested si vedono reciprocamente i membri \inline{private}\footnote{Vero significato di \inline{private} è "privato a livello della outerclass più esterna".}.
	\item Se B è classe è instanziabile (\inline{new}).
	\item Il nesting può essere multiplo e/o multilivello.
	\item Per le interfacce innestate il \inline{public static} è implicito.
\end{itemize}

Approcci:
\begin{enumerate}
	\item Outer è la classe astratta e le StaticNested pubbliche sono le implementazioni.
	\item StaticNested privata per sotto-comportamenti (implementaizone interfaccie o estensione classe) di Outer.
	\item StaticNested sono sotto stati dell'Outer non usabili indipendentemente.
\end{enumerate}

\subsection{Inner Class}
Dentro una classe A outer si inserisce la definizione d'una classe B inner (membro non-statico).

\multiline{}{}{CodiciEsempio/innerClass.java}

Precisazioni:
\begin{itemize}
	\item Inner si richiama su un instanza di Outer (enclosing instance), \textbf{Outer.InnerClass}, secondo il modificatore d'accesso.
	\item Un oggetto Inner si crea da un'istanza di Outer, \textbf{... = OuterObj.new Inner(...);}, secondo il modificatore d'accesso.

	Dentro Outer si fa \textbf{... = this.new Inner(...);}.
	\item Inner accede al enclosing instance con \inline{Outher.this}.
\end{itemize}

Approccio: preferibile a classi innestate statiche quando \inline{private}.

\subsubsection{Local Class}
Dentro un metodo d'una classe A Outer si inserisce la definizione d'una classe B local class (Inne Class di fatto).

\multiline{}{}{CodiciEsempio/localClass.java}

Può usare direttamente (senza \inline{this}) variabili final/di fatto final del metodo.

Approccio: Quando ho bisogno della classe solo dentro un metodo.

\subsubsection{Classi anonime}
Classi senza nome e costruttori creta al volo (Local Class di fatto) e da lì creta al volo un'istanza.

\multiline{}{}{CodiciEsempio/classiAnonime.java}

\begin{itemize}
	\item Il metodo "contenitore" restituisce come tipo la classe anonima.
	\item Può usare direttamente (senza \inline{this}) campi dell'Outer class.
\end{itemize}

Approccio: Utile per implementare interfacce e quando si deve creare un solo oggetto.

\subsection{Lambda expression}
