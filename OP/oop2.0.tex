\section{OOP2.0}
Nella OOP1.0 abbiamo il riuso per composizione, estensione, poliformismo inclusivo (subtyping).

La OOP2.0 aggiunge il poliformismo parametrico (generics), ???, con lo scopo di dare maggiore controllo al programmatore e espressività al linguaggio JAVA.

\begin{center}
	\begin{tikzcd}
		{[.java]} \arrow[rr, "Compilatore"] \arrow[rr, "JavaNew \to JavaVintage"', dotted, bend right] &  & {[.class]} \arrow[rr, "JVM"] &  & {[.exe]}
	\end{tikzcd}
\end{center}

Il compilatore risolve i costrutti della OOP2.0 trasformandoli in costrutti della OOP1.0 lasciando la JVM invariata.

\subsection{Generics}
\colTwo{\textbf{Scopo}: Creare funzionalità di lavorare uniformemente su oggetti indipendentemente dal loro tipo che diventa un parametro della funzionalità.}{\textbf{Vantaggio}: Fattorizzare, tramite astrazione, soluzioni/classi ricorrenti altamente simili in una unica soluzione/classe riusabile.}{45}{45}

Concetti chiave:
\begin{itemize}
	\item La \textbf{type-variable}, solitamente "X", è una variabile che contiene il tipo dell'oggetto a run-time.
	\item La type-variable è usabile ogni qualvolta si potrebbe scrivere un tipo.
	\item Possono esserci più type-variable.
	\item Tipi primiti non accettati, usare i Wrapper automaticamente risolti dall'autoboxing.
	\item Non passare tutti type-variabile lato utente è errrore.
\end{itemize}

\multiline{}{}{CodiciEsempio/Generici.java}
\textbf{Inferenza dei parametri}: Nella \inline{new} i type-variabile si omettono lasciando il \textit{diamond symbol} "$<>$". Alternativa usare la \inline{var}. In rari casi entrambi.

\bigskip

Per creare contratti uniformi si fanno interfacce generiche:

\oneline{... interface <nomeInterfaccia><X [, Y, ...] \{...\}}

Le type-variable sono usate nei metodi defini e le classi implementative le deve istanziare.

\bigskip

Metodi che lavorano e restituiscono qualsiasi tipo:

\oneline{def:... <X [, Y, ...]> <tipoRitorno> <nomeMetodo>(<parametri>) \{...\}}

\oneline{call:... <X, [Y, ...]><nomeMetodo>(<parametri>)...}

Inferiti automatica alla chiamata (non serve diamond symbol).

\subsubsection{Problema type-erasure}
Il compilatore, in fase \textit{erasure}, sostituisce i generics usando il subtyping di object e facendo upcast implicito nelle classi che diventano monomorfiche, mentre lato utente usa autoboxing e downcast esplicito.

Limitazioni implementative:
\begin{itemize}
	\item Non si possono istanziare oggetti (\inline{new}) di tipo type-variabile.
	\item Non è usabile \inline{instanceof type-variabile | nomeClasse<X>}.
	\item Il downcast esplicito da unchecked warning\footnote{Non rompe il programma nel punto del warning ma lo diffonde altrove nel codice dove prima o poi si romperà.}.
	\item Non posso fare array di generics. Vanno fatti array di \inline{object} con i dovuti cast oppure vanno usate le liste.
\end{itemize}

\subsection{Wildcards}
Le whidcards (poliformismo vincolare) permettono di esprimere un insieme di tipi accettati dai parametri di metodo che usa generics.

Permettono di usare oltre ai metodi di Object anche quelli delle classi indicate.

\oneline{<tipo> <nomeMetodo>(Tipo<? extends | super tipoRiferimento> nome,...) \{...\}}

\begin{itemize}
	\item \textbf{extends X}: Bounded covariante. Accetta i sotto tipi di X oltre a X.

	Non usare metodi set (read only).
	\item \textbf{super X}: Boundend controvariante. Accetta i sovra tipi di X oltre a X.

	Non usare metodi get (write only).
	\item Solo \inline{?}, Unbounded, indica qualsiasi type-variabile. Come dire \inline{? extends Object}. Da un codice leggero.
\end{itemize}

\textbf{Importante}: Se due tipi sono sostituibili (covatianza e controvarianca) tra loro non è detto che sempre una classe generics che li implementa entrambi sia sostituibile (Unsafety).
Gli array, simili a un tipo generic, sono unsafety perchè permettono covarianza.

Le wildcards possono essere usate insieme ai generics.

\subsection{Classi innestate}

\subsection{Lambda expression}