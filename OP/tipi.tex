\section{(Almost) Everything is an object}
Le variabili, contenitori con nomi, ora non denotano solo valori numerici (come in C), ma anche veri e propri oggetti irriducibili.

Non ci sono meccanismi per controllo diretto memoria. Le variabili sono nomi "locali" con riferimenti ad'\textit{oggetti} e non maschere di indirizzi in memoria a cui accedere direttamente.

Le variabili posso essere di tipo \textit{Java Types} quindi classi predefinite e autoimplementate oppure \textit{tipi primitivi}.

Visibilità legata al blocco di definizione.
Variabili non inizializzate sono inutilizzabili.

\subsection{Stack e Heap}
Gli oggetti sono memorizzati nell'\textbf{heap}. Tutte le variabili sono memorizzate nello \textbf{stack}.

Le variabili di tipo primitivo contengono direttamente il valore. Le variabili tipo classe contengono il riferimento dell'oggetto oppure null.

Nota: Uno stesso oggetto può essere puntato da variabili che si riferiscono alla stessa identità.

\subsection{Tipi Primitivi}
Ripasso: Un tipo classifica valori/oggetti tramite un nome, set valori, operatori.

I tipi atomici \textbf{signed} del C si sono mantenuti (non conveniva trattarli come oggetti) definendo un unica interpretazione:
\begin{center}
	\begin{tabular}{llll}
		\hline
		Tipi  primitivi & Dimensione & Minimo & Massimo \\
		\hline
		boolean & -- & -- & -- \\
		char & 16bits & Unicode 0 & Unicode $2^{16}-1$ \\
		byte & 8bits & -128 & +127 \\
		short & 16bits & $-2^{15}$ & $-2^{15}-1$ \\
		int & 32bits & $-2^{31}$& $+2^{31}-1$ \\
		long & 64bits  & $-2^{63}$& $-2^{63}-1$\\
		float & 32bits & IEEE754 & IEEE754 \\
		double & 64bits & IEEE754 & IEEE754 \\
		\hline
	\end{tabular}

	{\tiny Le librerie \textit{BigDecimal, BigInteger} gestiscono numeri di dimensione/precisione arbitraria.}
\end{center}

\textbf{typing statico}: espressioni tipo noto al compilatore, vantaggio intercettazione errori.

\textbf{Nota:} Uso memoria non dato a sapere al programmatore.

\subsubsection{Boolean}
Introdotto come tipo risultato delle espressioni e condizioni.
\begin{itemize}
	\item \textbf{Valori} true, false.
	\item \textbf{Operatori Unari} \inline{! (not)}. Peratori binari: \inline{\& (and), | (or), \^ (xor), \&\& (and-C), || (or-c)}\footnote{\inline{& e |} valutano sempre primo e secondo termine, essendo pensati per operazioni bit a bit mentre \inline{&& e ||} valotano il secondo operatore solo se necessario.}.
	\item \textbf{Operatori confronto numerici} \inline{<, >, <=, >=}.
	\item \textbf{Operatori di uguaglianza} \inline{==, !=}. Con gli oggett di base confronta i riferimenti.
	\item \textbf{Operatore ternario} \inline{<eb> ? e1 : e2}. restituisce e1 se eb è true, altrimenti restituisce e2. e1 e e2 espressioni dello stesso tipo.
\end{itemize}

\subsubsection{Caratteri}
Rappresentazione \inline{'carattere'} o \inline{'\u<0-65535>'}. Formato ASCII o UTF16 (16bit). I caratteri d'escape si fanno \inline{'\\<specificatore>'}.

\subsubsection{Interi}
\begin{itemize}
	\item \textbf{Codificati} in complemento a 2.
	\item \textbf{Operatori} \inline{+ ,-, *, /, \%, + e - unari, \&, |, ~, <<, >>, >>>}. Output stesso tipo Input.
	\item \textbf{Rappresentabili} in codifica decimale (1\_000\_000), ottale (0...), esadecimale (0x...).
	\item \textbf{Input tastiera} default int (più usato e efficente). Se voglio un long va aggiunta una "l" dopo il numero.
\end{itemize}

\subsubsection{Virgola mobile}
\begin{itemize}
	\item \textbf{Operatori} \inline{+ ,-, *, /, \%, + e -} unari.
	\item \textbf{Codificati} in IEEE754.
	\item \textbf{Rappresentabili} in codifica decimale o scientifica.
	\item \textbf{Input tastiera} default double. Se voglio un float (più efficente) va aggiunta una "f" dopo il numero.
\end{itemize}
\textbf{Ricorda}: IEEE754 ha errori di precisione che portano all'approssimazione dei risultati.

\subsection{Conversioni}
\begin{itemize}
	\item \textbf{Implicita} automaticamente applicata nelle esperessioni e nell'assegnamento portando tutti tipi a quello più "generale" presente nell'espressione. Detta \textit{coercizione}.

	$byte\to short \to int \to long \to float \to double$
	\item \textbf{Esplicito} fatto con operatore di casting: \inline{...=(<tipo>)<espressione>;}. Può causare perdità di informazioni.
\end{itemize}

\subsection{tipo statico e a rum-time}
\begin{itemize}
	\item \textbf{Tipo Statico}: Tipo di un espressione desumibile dal compilatore.
	\item \textbf{Tipo run-time}: Tipo effettivamente presente è tipo statico o sottotipo.
\end{itemize}

Per ispezionare il tipo a run-time:

\oneline{<espressione> instanceof <tipo>}

Restituisce \inline{boolean} e usato nella condizione di un \inline{if} permette di specializzare esecuzione.
\bigskip

\textbf{Downcast}: Creare nuovo riferimento di tipo statico all'espressione (da sovraTipo a sottoTipo):

\oneline{... (<tipoEffettio>)<espressione> ...}

\subsection{Autoboxing}
Ogni tipo primitivo può essere "boxed" in un oggetto.

\begin{itemize}
	\item \textbf{boxing} azione di inscatolamento di un tipo primitivo in un oggetto.
	\oneline{<Tipo> <variabile> = <Tipo>.valueOf(<tipoPrimitivo>)}
	\item \textbf{de-boxing} azione di estrarre un tipo primitivo da un ogetto.
	\oneline{... <varOggetto>.<tipoPrimitivo>Value() ...}
\end{itemize}

Boxing e De-boxing sono effettuati in automatico.

\subsection{Array}
Oggetti (variabili hanno riferimento nello heap) di lunghezza esplicita e acessibile, inacessibile fuori dai limiti (errore esecuzione), mutabili. Indirizzi elementi [0, lunghezza-1].

Sintassi:
\begin{itemize}
	\item \inline{<tipo>[] <nome> = new <tipo>[] \{v1,...,vn\};}
	\item \inline{<tipo>[] <nome> = new <tipo>[<dim>];}. Elementi inizializzati a valore default tipo (false, 0, null).
	\item \inline{<tipo>[] <nome> = \{v1,...,vn\};}
\end{itemize}

Note: Si possono fare array di array. Gli array di oggetti sono oggetti con puntatori ad'altri oggetti.

Accesso a variabile \inline{... <nome>[<ind>] ...}.

Per sapere la lunghezza dell'array \inline{<nome>.length}.

\subsubsection{Foreach}
Astazione \inline{for} in sola \textbf{lettura}, utile quando non importa ordine scorrimento elementi collezione e valore indice.

\oneline{for(final<tipo> <v>: <e>)}

\begin{itemize}
	\item \inline{v} è variabile del tipo indicato che vale via via ogni elemento della colezzione.
	\item \inline{e} è un espressione che restituisce una collezione di elementi del tipo indicato.
	\item Si può esplicitare \inline{final}, anche se non servirebbe, perchè il foreach crea una nuova variabile a ogni iterazione in realtà.
\end{itemize}