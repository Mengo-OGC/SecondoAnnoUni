\section{Programmazione Concorrente}
Inclusioni necessarie:
\begin{itemize}
	\item \textbf{\#include \textless sys/types.h\textgreater} Definire tipi di dato speciali usati nelle chiamate di sistema.
	\item \textbf{\#include \textless unistd.h\textgreater} Include funzioni e costanti del sistema operativo Linux/Unix.
\end{itemize}

\tabella{Multi-processo}{
	\riga{fork()}{Crea un processo figlio. Condivide codice successivo alla fork e possiede una copia dei dati.

	Restituisce il pid del figlio al padre ($PID_F>0$) e 0 al figlio ($PID_F=0$) o un codice d'errore (<0).}

	\riga{exit(0)}{Termina un processo restituendo lo stato indicato come parametro (0 stato successo).

	Se padre termina prima del figlio non si possono liberare le risorse.}

	\riga{wait(NULL)}{Fa attendere al processo la terminazione del processo figlio. Restituisce il pid del processo terminato.}

	\riga{wait(pidProcesso)}{Fa attendere al processo corrente uno specifico processo.}

	\riga{waitpid(pidProcesso, \&status, statoAttesso)}{Fa aspettare un thread specifico con uno stato specifico.}

	\riga{exec}{Sostituisce codice e dati a un processo. Non crea processi figlio.}
}
Un processo possiede: Il proprio PID (gestito dall'os), il PID del processo figlio o 0 e il pid del processo "iziale" (gestito da descrittore di file).

Struttura base programma multi-processo:
\begin{verbatim}
int main() {
				pid_t pid;

				pid = fork();

				if (pid < 0) { "gestione errore" }
				else if (pid == 0) { "processo figlio" }
				else { "processo padre" }
}
\end{verbatim}

Ogni processo tiene referenza di un unico figlio, anche se ne può creare diversi. Quindi dopo ogni fork è buona cosa separare i flussi dei due processi.





\tabella{PIPE}{
	\riga{pipe(varPipe[2] : int) : int}{Crea una pipe unidirezionale.

	Su varPipe[0] si leggerà. Su varPipe[1] si scriverà.

	Restituisce -1 in caso di errore, 0 se creazione avviene con successo.}
	\riga{close(varPipe[0\textbar1])}{Chiude una estremità della pipe.}
	\riga{read(varPipe[0], buffer, bufferSize)}{Blocca esecuzione in attesa di dati da leggere.}
	\riga{strcpy(buffer, "...")}{Prepara il buffer con il messaggio da inviare.}
	\riga{write(varPipe[1], buffer, sizeBuffer+1)}{Scrive nella pipe.}
}

Permette di comunicare fra processi correlati usando sistem-call e i descrittori di file. Il collegamento esiste fino a eliminazione esplicita o del processo.

\begin{center}
	\begin{tikzpicture}
		\draw[draw=black, thin, solid] (-6.00,3.00) rectangle (-1.50,-1.00);
		\draw[draw=black, thin, solid] (-5.50,2.00) rectangle (-4.50,-0.50);
		\draw[draw=black, thin, solid] (-4.00,1.50) rectangle (-2.00,0.50);
		\draw[draw=black, thin, solid] (-4.00,0.50) rectangle (-2.00,-0.50);
		\node[black, anchor=south west] at (-6.06,3.25) {P1};
		\node[black, anchor=south west] at (-5.56,2.25) {Buffer};
		\node[black, anchor=south west] at (-4.06,0.75) {Read};
		\node[black, anchor=south west] at (-4.06,-0.25) {Write};
		\node[black, anchor=south west] at (-4.06,1.75) {PIPE};
		\draw[draw=black, thin, solid] (0.50,3.00) rectangle (5.00,-1.00);
		\draw[draw=black, thin, solid] (3.50,2.00) rectangle (4.50,-0.50);
		\draw[draw=black, thin, solid] (1.00,1.50) rectangle (3.00,0.50);
		\draw[draw=black, thin, solid] (1.00,0.50) rectangle (3.00,-0.50);
		\node[black, anchor=south west] at (0.44,3.25) {P2};
		\node[black, anchor=south west] at (3.44,2.25) {Buffer};
		\node[black, anchor=south west] at (0.94,1.75) {PIPE};
		\node[black, anchor=south west] at (0.94,0.75) {Write};
		\node[black, anchor=south west] at (0.94,-0.25) {Read};
		\draw[draw=black, -latex, thin, solid] (-2.00,1.00) -- (1.00,1.00);
		\draw[draw=black, -latex, thin, solid] (1.00,0.00) -- (-2.00,0.00);
	\end{tikzpicture}
\end{center}

Ogni processo ha un buffer di caratteri e una pipe (array di due celle) per scrivere e leggere con l'altro processo i dati contentuti nel buffer.

Nota: I processi sono visti come file, per questo le operazioni si chiamano come quelle dei file.

\tabella{Multi-thread}{
	\riga{nomeFunzioneThread(arg : void*) : void*}{Funzione assegnata da eseguire a un thread.

	Necessita questa firma specifica per accettare e restituire qualsiasi tipo di dato. Serve eseguire un cast esplicito.}
	\riga{pthread\_create(\&varThread, \&pthreadAttribut, tFunction, \&args)}{Crea un nuovo thread dentro al processo corrente. I parametri sono:
	\begin{enumerate}
		\item Variabile tipo thread.
		\item Puntatore a struttura di attributi del thread. Default è NULL.
		\item Funzione che sarà eseguita dal thread.
		\item Puntatore a struttura contenente parametri usati dalla funzine.
	\end{enumerate}}
	\riga{pthread\_join(\&varThread, NULL)}{Fa attendere processo la fine del thread indicato.}
}

Struttura base programma multi-processo:
\begin{verbatim}
void *tFunction(void *args) {...}
int main() {
				pthread_t thread;
				... args = ...;

				ptread_create(&thread, NULL, tFunction, &args);
}
\end{verbatim}

Nota: La creazione di un processo è più lenta della creazione di un thread perchè nella prima bisogna creare un intero file descriptor, mentre nella seconda parziale.

\subsection{SJF}
Calcolo approssimato CPU Bust: $T_{n+1}=\alpha t_n+(1-\alpha)T_n$.
\begin{itemize}
	\item $t_m$ tempo n-esimo CPU burst. Storia recente.
	\item $T_{n}$ previsione prevista. Storia passata.
	\item $\alpha$ peso storia recente e passata.
\end{itemize}
Calcolo Media esponensiale: $T_{n+1}=\sum_{j=0}^n\alpha(1-\alpha)^jt_{n-j}+(1-\alpha)^{n+1}T_0$.